package com.example.bluetoothvulnerabilityscanner;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;

import android.Manifest;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.os.Bundle;

import android.os.Build;
import android.widget.ListView;

import androidx.annotation.RequiresApi;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.content.Intent;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.Toast;

import com.google.firebase.database.DataSnapshot;
import com.google.firebase.database.DatabaseError;
import com.google.firebase.database.DatabaseReference;
import com.google.firebase.database.FirebaseDatabase;
import com.google.firebase.database.ValueEventListener;

import java.lang.reflect.Array;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;


public class ScanAroundDevices extends AppCompatActivity implements AdapterSearchAroundDevices.OnItemListener{

        private static final String TAG = "ScanAroundDevices";
        private DatabaseReference UserEntryDatabase;
        private DatabaseReference PhoneModelDatabase;

        Context context = this;

        BluetoothAdapter mBluetoothAdapter;
        public ArrayList<DataSearchAroundDevices> list = new ArrayList<>();
        public ArrayList<DataSearchDevice> userEntryDatalist = new ArrayList<>();
        public ArrayList<DataPhoneModelNumber> phoneModelDataList = new ArrayList<>();
        public ArrayList<String> phoneModelNumberList = new ArrayList<>();

        public AdapterSearchAroundDevices adapterSearchAroundDevices;

        RecyclerView recyclerView;
        private int PERMISSION_CODE = 1000;
        private int btnDiscoverCounter = 0;



        private final BroadcastReceiver mBroadcastReceiver1 = new BroadcastReceiver() {
            public void onReceive(Context context, Intent intent) {
                String action = intent.getAction();

                if (action.equals(mBluetoothAdapter.ACTION_STATE_CHANGED)) {
                    final int state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, mBluetoothAdapter.ERROR);

                    switch (state) {
                        case BluetoothAdapter.STATE_OFF:
                            Log.d(TAG, "onReceive: STATE OFF");
                            break;
                        case BluetoothAdapter.STATE_TURNING_OFF:
                            Log.d(TAG, "mBroadcastReceiver1: STATE TURNING OFF");
                            break;
                        case BluetoothAdapter.STATE_ON:
                            Log.d(TAG, "mBroadcastReceiver1: STATE ON");
                            break;
                        case BluetoothAdapter.STATE_TURNING_ON:
                            Log.d(TAG, "mBroadcastReceiver1: STATE TURNING ON");
                            break;
                    }
                }
            }
        };


        /**
         * Broadcast Receiver for listing devices that are not yet paired
         * -Executed by btnDiscover() method.
         */
        private BroadcastReceiver mBroadcastReceiver3 = new BroadcastReceiver() {

            @Override
            public void onReceive(Context context, Intent intent) {
                final String action = intent.getAction();

                Log.d(TAG, "mBroadCastReceiver3 Received.");

                if (action.equals(BluetoothDevice.ACTION_FOUND)) {
                    BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
                    String deviceName = device.getName();
                    String deviceAddress = device.getAddress();

                    //call function to add values into list and get vulnerability status
                    showDevices(deviceName, deviceAddress);
                    Log.d(TAG, "onReceive: " + device.getName() + ": " + device.getAddress());

                }
            }
        };


        @Override
        protected void onDestroy() {
            Log.d(TAG, "onDestroy: called.");
            super.onDestroy();

            //not possible to check which receivers are registered. hence, use try and catch.

            try {
//                unregisterReceiver(mBroadcastReceiver1);
                unregisterReceiver(mBroadcastReceiver3);
            }catch(IllegalArgumentException e) {
                e.printStackTrace();
            }
        }


        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_scan_around_devices);
            setTitle("Scan Around Devices");

            recyclerView = findViewById(R.id.deviceRecycleView);
            recyclerView.setHasFixedSize(true);
            recyclerView.setLayoutManager(new LinearLayoutManager(context));

            FirebaseDatabase database = FirebaseDatabase.getInstance("https://bluetoothvulnscannerdb-default-rtdb.asia-southeast1.firebasedatabase.app");
            UserEntryDatabase = database.getReference("Users");
            PhoneModelDatabase = database.getReference("Phone_Model");

            list = new ArrayList<>();
            mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();

            checkBTPermissions();


            //get all the data of User Entries.
            if (UserEntryDatabase != null) {
                UserEntryDatabase.addValueEventListener(new ValueEventListener() {

                    @Override
                    public void onDataChange(@NonNull DataSnapshot snapshot) {
                        if (snapshot.exists()) {

                            list = new ArrayList<>();

                            for (DataSnapshot ds : snapshot.getChildren()) {

                                String userID = ds.getKey();
                                DataSnapshot scanResultsBranch = ds.child("scanresults");

                                for (DataSnapshot ds2 : scanResultsBranch.getChildren()) {
                                    String userSubmissionID = ds2.getKey();
                                    String manufacturer = ds2.child("manufacturer").getValue(String.class);
                                    String model = ds2.child("model").getValue(String.class);

                                    String manufacturerdmodel = manufacturer + " " + model;
                                    String androidversion = ds2.child("release").getValue(String.class);
                                    String chipset = ds2.child("chipset").getValue(String.class);

                                    String socmodel = ds2.child("socmodel").getValue(String.class);
                                    String socmanufacturer = ds2.child("socmanufacturer").getValue(String.class);

                                    String socmanufacturermodel = socmodel + ", " + socmanufacturer;

                                    if (chipset.equals("unknown")) {
                                        chipset = socmanufacturermodel;
                                    }

                                    Long dateofscan = ds2.child("date").getValue(Long.class);

                                    //default to 0 first. Will add up in the next part.
                                    int vulnerabilityCount = 0;

                                    //not all will have vulnerabilities as such default as 0 above.
                                    DataSnapshot Branch = ds2.child("vulnerabilities");

                                    Long vulnerabilityCountHolder = Branch.getChildrenCount();

                                    if (vulnerabilityCountHolder != null) {
                                        vulnerabilityCount = vulnerabilityCountHolder.intValue();
                                    }
                                    userEntryDatalist.add(new DataSearchDevice(userSubmissionID, manufacturerdmodel, androidversion, chipset, dateofscan, vulnerabilityCount));
                                }
                            }
                        }
                    }

                    @Override
                    public void onCancelled(@NonNull DatabaseError error) {
                        Log.d("SearchDevices", "DATABASE ERROR", error.toException());
                    }
                });
            }


            //get all the data of Phone Model in DB.
            if (PhoneModelDatabase != null) {
                PhoneModelDatabase.addValueEventListener(new ValueEventListener() {

                    @Override
                    public void onDataChange(@NonNull DataSnapshot snapshot) {
                        if (snapshot.exists()) {

                            list = new ArrayList<>();

                            for (DataSnapshot ds : snapshot.getChildren()) {

                                String modelName = ds.getKey();
                                String brand = ds.child("Brand").getValue(String.class);

                                Log.v(TAG, "modelName: " + modelName);
                                Log.v(TAG, "brand: " + brand);

                                DataSnapshot modelNumberSnapshot = ds.child("Model Number");
                                if (modelNumberSnapshot.exists()) {
                                        phoneModelNumberList = new ArrayList<>();

                                    for (DataSnapshot ds2 : modelNumberSnapshot.getChildren()) {

                                        String modelNumber = String.valueOf(ds2.getValue());
                                        Log.v(TAG, "modelNumber: " + modelNumber);

                                        phoneModelNumberList.add(modelNumber);
                                    }
                                }

                                phoneModelDataList.add(new DataPhoneModelNumber(modelName, brand, phoneModelNumberList));
                            }
                        }
                    }

                    @Override
                    public void onCancelled(@NonNull DatabaseError error) {
                        Log.d("SearchDevices", "DATABASE ERROR", error.toException());
                    }
                });
            }
        }



        public void enableBluetooth() {
            if (mBluetoothAdapter == null) {

                //alert users their device does not have bluetooth capabilities.
                Toast.makeText(ScanAroundDevices.this, "Bluetooth is not available on this device", Toast.LENGTH_LONG).show();
                Log.d(TAG, "enableBluetooth: Does not have BT capabilities.");

            }else{

                if (!mBluetoothAdapter.isEnabled()) {
                    Log.d(TAG, "enableBluetooth: enabling BT.");
                    Intent enableBTIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
                    startActivity(enableBTIntent);

                    IntentFilter BTIntent = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
                    registerReceiver(mBroadcastReceiver1, BTIntent);

                }
            }
        }



        public void Discover() {
            Log.d(TAG, "btnDiscover: Looking for unpaired devices.");

            if (btnDiscoverCounter == 0) {

                if (mBluetoothAdapter.isDiscovering()) {

                    mBluetoothAdapter.cancelDiscovery();
                    Log.d(TAG, "btnDiscover: Canceling discovery.");

                }

                Log.d(TAG, "mBluetoothAdapter: started discovery.");

                IntentFilter discoverDevicesIntent = new IntentFilter(BluetoothDevice.ACTION_FOUND);
                discoverDevicesIntent.addAction(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);
                Log.d(TAG, "discoverDevicesIntent: IntentFilter established with value of: " + discoverDevicesIntent);

                registerReceiver(mBroadcastReceiver3, discoverDevicesIntent);
                Log.d(TAG, "mBroadcastReceiver3: receiver registered with discoverDevicesIntent.");

                mBluetoothAdapter.startDiscovery();
                btnDiscoverCounter+=1;
            }
        }

    @Override
    public void onItemClick(int position) {

        String deviceName = list.get(position).getDeviceName();

        ArrayList combinedUserEntryID = list.get(position).getCombinedUserEntryID();


        Log.d("onItemClick", deviceName);

        int entryCount = list.get(position).getEntryCount();
        if(entryCount > 0){

        Intent intent = new Intent (context, ScanAroundDevicesResult.class);

        //put the arraylist containing the user entry ID  here.
        intent.putExtra("combinedUserEntryID", combinedUserEntryID);

        startActivity(intent);

        }

    }

    private void showDevices(String deviceName, String deviceAddress){
        if(deviceName == null || deviceName.equals("")){
            deviceName = "unknown";
        }

        Map vulnerabilitStatusEntryCount = search(deviceName);

        ArrayList<String> listOfStrings = (ArrayList<String>) vulnerabilitStatusEntryCount.get("strings");
        ArrayList<Integer> listOfIntegers = (ArrayList<Integer>) vulnerabilitStatusEntryCount.get("integers");
        ArrayList<String> combinedUserEntryID = (ArrayList<String>) vulnerabilitStatusEntryCount.get("combineduserentryID");;

        Log.v(TAG, "listOfStrings: " + listOfStrings.get(0));
        Log.v(TAG, "listOfIntegers: " + listOfIntegers.get(0));

        String vulnerabilityStatus = listOfStrings.get(0);
        Integer entryCount = listOfIntegers.get(0);

        Log.v(TAG, "entryCount: " + entryCount);
        Log.v(TAG, "vulnerabilityStatus: " + vulnerabilityStatus);

        list.add(new DataSearchAroundDevices(deviceName, deviceAddress, vulnerabilityStatus, entryCount, combinedUserEntryID));

        adapterSearchAroundDevices = new AdapterSearchAroundDevices(context, list, this);
        recyclerView.setAdapter(adapterSearchAroundDevices);
        adapterSearchAroundDevices.notifyDataSetChanged();
    }

    public Map<String, List> search(String discoveredDevice) {

            HashMap<String, List> hashMap = new HashMap<String,List>();
            ArrayList<String> listOfStrings = new ArrayList<String>();
            ArrayList<String> finalCombinedUserEntryID = new ArrayList<String>();

            ArrayList<Integer> listOfIntegers = new ArrayList<Integer>();
            ArrayList<String> combinedUserEntryID = new ArrayList<String>();

            int entryCount = 0;
            int vulnerabilityCount = 0;
            int vulnerabilityCountHolder;

            String vulnerabilityStatus  = "No Vulnerability Detections";

            Log.v("userEntryDatalistsize", String.valueOf(userEntryDatalist.size()));

        if (discoveredDevice != "unknown") {

            Log.d(TAG, "discoveredDevice: " + discoveredDevice);

            for (int u = 0; u < phoneModelDataList.size(); u++) {

//                String phoneBrand = phoneModelDataList.get(u).getBrand();
                String phoneModelName = phoneModelDataList.get(u).getModelName();
                ArrayList<String> phoneModelNumberArray = phoneModelDataList.get(u).getPhoneModelNumberList();


                //if phonemodelname not null,
                if (phoneModelName != null) {

                    Log.d(TAG, "discoveredDevice: " + discoveredDevice);
                    Log.d(TAG, "phoneModelName: " + phoneModelName);

                        //find if the discovered device name contains the model name in the database table.
                        if (discoveredDevice.toLowerCase().contains(phoneModelName.toLowerCase())){

                            Log.v(TAG, "discoveredDevice contains phoneModelName: " + phoneModelName);

                            for (int r = 0; r < phoneModelNumberArray.size(); r++) {

                                Integer size = phoneModelNumberArray.size();
                                Log.d(TAG, "phoneModelNumberArray: " + size);

                                String phoneModelNumber = phoneModelNumberArray.get(r);

                                for (int i = 0; i < userEntryDatalist.size(); i++) {
                                    String manufacturermodel = userEntryDatalist.get(i).getManufacturerModel();

                                    if (manufacturermodel.toLowerCase().contains(phoneModelNumber.toLowerCase())) {

                                        Log.v(TAG, "manufacturermodel contains phoneModelNumber: " + phoneModelNumber);

                                        entryCount += 1;

                                        vulnerabilityCountHolder = userEntryDatalist.get(i).getVulnerabilities();
                                        vulnerabilityCount += vulnerabilityCountHolder;
                                        Log.v(TAG, "vulnerabilityCount: " + vulnerabilityCount);

                                        String userSubmissionID = userEntryDatalist.get(i).getuserSubmissionID();
                                        combinedUserEntryID.add(userSubmissionID);

                                        Log.v("userSubmissionID: ", userSubmissionID);

                                }
                                    //sometimes like manufacturers dont standardize
                                    //model number and model name POCOPHONE F1 has a model number of "M1805E10A". But in its build.model, it is stored
                                    //as POCOPHONE F1.
                                    else if(manufacturermodel.toLowerCase().contains(phoneModelName.toLowerCase())){

                                        Log.v(TAG, "manufacturermodel contains manufacturermodel: " + manufacturermodel);

                                        entryCount += 1;

                                        vulnerabilityCountHolder = userEntryDatalist.get(i).getVulnerabilities();
                                        vulnerabilityCount += vulnerabilityCountHolder;
                                        Log.v(TAG, "vulnerabilityCount: " + vulnerabilityCount);

                                        String userSubmissionID = userEntryDatalist.get(i).getuserSubmissionID();
                                        combinedUserEntryID.add(userSubmissionID);

                                        Log.v("userSubmissionID: ", userSubmissionID);

                                    }
                                }
                            }
                        }
                    }
                }
            }


        // Remove duplicates
        HashSet<String> set = new HashSet<String>(combinedUserEntryID);

        // Convert back to ArrayList
        finalCombinedUserEntryID = new ArrayList<String>(set);

        for(int i = 0; i < finalCombinedUserEntryID.size(); i++){

            Log.v(TAG, "finalCombinedUserEntryID: " + finalCombinedUserEntryID.get(i));

        }

        if (vulnerabilityCount > 0){
            vulnerabilityStatus = "Possible Vulnerability Detections";
        }

        listOfStrings.add(vulnerabilityStatus);
        listOfIntegers.add(entryCount);

        hashMap.put("strings",listOfStrings);
        hashMap.put("integers",listOfIntegers);
        hashMap.put("combineduserentryID", finalCombinedUserEntryID);

        return hashMap;
    }


        /**
         * This method is required for all devices running API23+
         * Android must programmatically check the permissions for bluetooth. Putting the proper permissions
         * in the manifest is not enough.
         *
         * NOTE: This will only execute on versions > LOLLIPOP because it is not needed otherwise.
         */

        private void checkBTPermissions(){
            Log.d(TAG, "checkBTPermissions: checking BT Permissions.");

            if (Build.VERSION.SDK_INT > Build.VERSION_CODES.LOLLIPOP) {
                int permissionCheck = 0;
                //check for permissions in manifest.
                permissionCheck += this.checkSelfPermission("Manifest.permission.BLUETOOTH");
                permissionCheck += this.checkSelfPermission("Manifest.permission.BLUETOOTH_ADMIN");
                permissionCheck += this.checkSelfPermission("Manifest.permission.ACCESS_FINE_LOCATION");
                permissionCheck += this.checkSelfPermission("Manifest.permission.ACCESS_COARSE_LOCATION");

                //if permission check is not 0, means one of the permissions is not available. hence, request it
                if (permissionCheck != 0) {
                    Log.d(TAG, "permissionCheck: !=0 .");
                    this.requestPermissions(new String[]{Manifest.permission.BLUETOOTH,
                            Manifest.permission.BLUETOOTH_ADMIN, Manifest.permission.ACCESS_COARSE_LOCATION,
                            Manifest.permission.ACCESS_FINE_LOCATION}, 1000);
                }

            } else {
                Log.d(TAG, "checkBTPermissions: No need to check permissions. SDK version < LOLLIPOP.");
            }

        }


        @Override
        public void onRequestPermissionsResult ( int requestCode, @NonNull String[] permissions,
                                                 @NonNull int[] grantResults){
            super.onRequestPermissionsResult(requestCode, permissions, grantResults);
            if (requestCode == PERMISSION_CODE) {
                if (grantResults.length > 0) {

                    int grantresultslength = grantResults.length;
                    Log.v(TAG, "" + grantresultslength);
                    int r=0;

                    for (int i = 0; i < grantresultslength; i++) {

                        if (grantResults[i] == PackageManager.PERMISSION_GRANTED) {
                            Log.v(TAG, "PERMISSION" + i + " GRANTED");
                            r++;

                        } else {
                            Log.v(TAG, "PERMISSION" + i + " DENIED");
                        }}

                    //only if all permissions are  granted, we will enable bluetooth and allow users to start discovery
                    if(r==4){

                        enableBluetooth();
                        Button startDiscoveryButton = (Button) findViewById(R.id.btnFindUnpairedDevices);
                        startDiscoveryButton.setOnClickListener(new View.OnClickListener() {
                            @Override
                            public void onClick(View view) {
                                Log.d(TAG, "onClick: btnDiscover.");
                                Discover();
                            }});}
                } else {
                    Toast.makeText(this, "PERMISSION DENIED", Toast.LENGTH_SHORT).show();
                }
            }
        }
    }


