package com.example.bluetoothvulnerabilityscanner;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;

import android.Manifest;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.os.Bundle;

import android.os.Build;
import android.widget.ListView;

import androidx.annotation.RequiresApi;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.content.Intent;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.Toast;

import com.google.firebase.database.DataSnapshot;
import com.google.firebase.database.DatabaseError;
import com.google.firebase.database.DatabaseReference;
import com.google.firebase.database.FirebaseDatabase;
import com.google.firebase.database.ValueEventListener;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ScanAroundDevices extends AppCompatActivity implements AdapterSearchAroundDevices.OnItemListener{

        private static final String TAG = "ScanAroundDevices";
        private DatabaseReference UserEntryDatabase;

        Context context = this;

        BluetoothAdapter mBluetoothAdapter;
        Button btnEnableDisable_Discoverable;
        public ArrayList<DataSearchAroundDevices> list = new ArrayList<>();
        public ArrayList<DataSearchDevice> userEntryDatalist = new ArrayList<>();
        public AdapterSearchAroundDevices adapterSearchAroundDevices;

//        ListView lvNewDevices;
        RecyclerView recyclerView;
        private int PERMISSION_CODE = 1000;
        private int btnDiscoverCounter = 0;


        // Create a BroadcastReceiver for ACTION_FOUND
        private final BroadcastReceiver mBroadcastReceiver1 = new BroadcastReceiver() {
            public void onReceive(Context context, Intent intent) {
                String action = intent.getAction();
                // When discovery finds a device
                if (action.equals(mBluetoothAdapter.ACTION_STATE_CHANGED)) {
                    final int state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, mBluetoothAdapter.ERROR);

                    switch (state) {
                        case BluetoothAdapter.STATE_OFF:
                            Log.d(TAG, "onReceive: STATE OFF");
                            break;
                        case BluetoothAdapter.STATE_TURNING_OFF:
                            Log.d(TAG, "mBroadcastReceiver1: STATE TURNING OFF");
                            break;
                        case BluetoothAdapter.STATE_ON:
                            Log.d(TAG, "mBroadcastReceiver1: STATE ON");
                            break;
                        case BluetoothAdapter.STATE_TURNING_ON:
                            Log.d(TAG, "mBroadcastReceiver1: STATE TURNING ON");
                            break;
                    }
                }
            }
        };

        /**
         * Broadcast Receiver for changes made to bluetooth states such as:
         * 1) Discoverability mode on/off or expire.
         */
        private final BroadcastReceiver mBroadcastReceiver2 = new BroadcastReceiver() {

            @Override
            public void onReceive(Context context, Intent intent) {
                Log.d(TAG, "mBroadcastReceiver2: Before if final string.");

                final String action = intent.getAction();

                if (action.equals(BluetoothAdapter.ACTION_SCAN_MODE_CHANGED)) {

                    int mode = intent.getIntExtra(BluetoothAdapter.EXTRA_SCAN_MODE, BluetoothAdapter.ERROR);

                    switch (mode) {
                        //Device is in Discoverable Mode
                        case BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE:
                            Log.d(TAG, "mBroadcastReceiver2: Discoverability Enabled.");
                            break;
                        //Device not in discoverable mode
                        case BluetoothAdapter.SCAN_MODE_CONNECTABLE:
                            Log.d(TAG, "mBroadcastReceiver2: Discoverability Disabled. Able to receive connections.");
                            break;
                        case BluetoothAdapter.SCAN_MODE_NONE:
                            Log.d(TAG, "mBroadcastReceiver2: Discoverability Disabled. Not able to receive connections.");
                            break;
                        case BluetoothAdapter.STATE_CONNECTING:
                            Log.d(TAG, "mBroadcastReceiver2: Connecting....");
                            break;
                        case BluetoothAdapter.STATE_CONNECTED:
                            Log.d(TAG, "mBroadcastReceiver2: Connected.");
                            break;
                    }

                }
            }
        };


        /**
         * Broadcast Receiver for listing devices that are not yet paired
         * -Executed by btnDiscover() method.
         */
        private BroadcastReceiver mBroadcastReceiver3 = new BroadcastReceiver() {

            @Override
            public void onReceive(Context context, Intent intent) {
                final String action = intent.getAction();

                Log.d(TAG, "mBroadCastReceiver3 Received.");

                if (action.equals(BluetoothDevice.ACTION_FOUND)) {
                    BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
                    String deviceName = device.getName();
                    String deviceAddress = device.getAddress();

                    //call function to add values into list and get vulnerability status
                    showDevices(deviceName, deviceAddress);
                    Log.d(TAG, "onReceive: " + device.getName() + ": " + device.getAddress());

                }
            }
        };


        @Override
        protected void onDestroy() {
            Log.d(TAG, "onDestroy: called.");
            super.onDestroy();
//        unregisterReceiver(mBroadcastReceiver1);
//        unregisterReceiver(mBroadcastReceiver2);
            //mBluetoothAdapter.cancelDiscovery();
        }


        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_scan_around_devices);
            Button btnONOFF = (Button) findViewById(R.id.btnONOFF);
            Button startDiscoverableButton = (Button) findViewById(R.id.btnDiscoverable_on_off);
            Button startDiscoveryButton = (Button) findViewById(R.id.btnFindUnpairedDevices);

            recyclerView = findViewById(R.id.deviceRecycleView);
            recyclerView.setHasFixedSize(true);
            recyclerView.setLayoutManager(new LinearLayoutManager(context));

            FirebaseDatabase database = FirebaseDatabase.getInstance("https://bluetoothvulnscannerdb-default-rtdb.asia-southeast1.firebasedatabase.app");
            UserEntryDatabase = database.getReference("User_Entry");


//            lvNewDevices = (ListView) findViewById(R.id.lvNewDevices);

            list = new ArrayList<>();

            mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
            checkBTPermissions();

            btnONOFF.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View view) {
                    Log.d(TAG, "onClick: enabling/disabling bluetooth.");
                    enableDisableBT();
                }
            });

            startDiscoverableButton.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View view) {
                    Log.d(TAG, "onClick: btnEnableDisable_Discoverable.");
                    btnEnableDisable_Discoverable();
                }
            });

            startDiscoveryButton.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View view) {
                    Log.d(TAG, "onClick: btnDiscover.");
                    btnDiscover();
                }
            });


//            //get all the data of User Entries.
            if (UserEntryDatabase != null) {
                UserEntryDatabase.addValueEventListener(new ValueEventListener() {

                    @Override
                    public void onDataChange(@NonNull DataSnapshot snapshot) {
                        if (snapshot.exists()) {

                            list = new ArrayList<>();

                            for (DataSnapshot ds : snapshot.getChildren()) {

                                String userSubmissionID = ds.getKey();
                                String manufacturer = ds.child("manufacturer").getValue(String.class);
                                String model = ds.child("model").getValue(String.class);

                                String manufacturerdmodel = manufacturer + " " + model;
                                String androidversion = ds.child("release").getValue(String.class);
                                String chipset = ds.child("chipset").getValue(String.class);

                                String socmodel = ds.child("socmodel").getValue(String.class);
                                String socmanufacturer = ds.child("socmanufacturer").getValue(String.class);

                                String socmanufacturermodel = socmodel + ", " + socmanufacturer;

                                if (chipset.equals("unknown")) {
                                    chipset = socmanufacturermodel;
                                }

                                String dateofscan = ds.child("date").getValue(String.class);

                                //default to 0 first. Will add up in the next part.
                                int vulnerabilityCount = 0;

                                //not all will have vulnerabilities as such default as 0 above.
                                DataSnapshot Branch = ds.child("vulnerabilities");

                                Long vulnerabilityCountHolder = Branch.getChildrenCount();

                                if(vulnerabilityCountHolder!=null) {
                                    vulnerabilityCount = vulnerabilityCountHolder.intValue();
                                }

                                userEntryDatalist.add(new DataSearchDevice(userSubmissionID, manufacturerdmodel, androidversion, chipset, dateofscan, vulnerabilityCount));


                            }
                        }

                    }

                    @Override
                    public void onCancelled(@NonNull DatabaseError error) {
                        Log.d("SearchDevices", "DATABASE ERROR", error.toException());
                    }
                });

            }
        }


        public void enableDisableBT() {
            if (mBluetoothAdapter == null) {
                Log.d(TAG, "enableDisableBT: Does not have BT capabilities.");
            }
            if (!mBluetoothAdapter.isEnabled()) {
                Log.d(TAG, "enableDisableBT: enabling BT.");
                Intent enableBTIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
                startActivity(enableBTIntent);

                IntentFilter BTIntent = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
                registerReceiver(mBroadcastReceiver1, BTIntent);
            }
            if (mBluetoothAdapter.isEnabled()) {
                Log.d(TAG, "enableDisableBT: disabling BT.");
                mBluetoothAdapter.disable();

                IntentFilter BTIntent = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
                registerReceiver(mBroadcastReceiver1, BTIntent);
            }

        }


        public void btnEnableDisable_Discoverable() {
            Log.d(TAG, "btnEnableDisable_Discoverable: Making device discoverable for 300 seconds.");

            Intent discoverableIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);
            discoverableIntent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 300);
            startActivity(discoverableIntent);

            IntentFilter intentFilter = new IntentFilter(BluetoothAdapter.ACTION_SCAN_MODE_CHANGED);
            Log.d(TAG, "intentFilter: IntentFilter established with value of: " + intentFilter);

            registerReceiver(mBroadcastReceiver2, intentFilter);
        }



        public void btnDiscover() {


            Log.d(TAG, "btnDiscover: Looking for unpaired devices.");

            if (btnDiscoverCounter == 0) {

                if (mBluetoothAdapter.isDiscovering()) {

                    mBluetoothAdapter.cancelDiscovery();
                    Log.d(TAG, "btnDiscover: Canceling discovery.");

                }

                Log.d(TAG, "mBluetoothAdapter: started discovery.");


                IntentFilter discoverDevicesIntent = new IntentFilter(BluetoothDevice.ACTION_FOUND);
                discoverDevicesIntent.addAction(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);
                Log.d(TAG, "discoverDevicesIntent: IntentFilter established with value of: " + discoverDevicesIntent);

                registerReceiver(mBroadcastReceiver3, discoverDevicesIntent);
                Log.d(TAG, "mBroadcastReceiver3: receiver registered with discoverDevicesIntent.");

                mBluetoothAdapter.startDiscovery();

                btnDiscoverCounter+=1;
            }
        }

    @Override
    public void onItemClick(int position) {

        String deviceName = list.get(position).getDeviceName();

        Log.d("onItemClick", deviceName);

//        if()

        Intent intent = new Intent (context, SearchDevices.class);
        intent.putExtra("deviceName", deviceName);
        startActivity(intent);

//        Intent intent = new Intent(context, SearchDeviceResult.class);
//        intent.putExtra("userSubmissionID", userSubmissionID);
//        startActivity(intent);

    }

    private void showDevices(String deviceName, String deviceAddress){
        if(deviceName == null || deviceName.equals("")){
            deviceName = "unknown";
        }

//        String vulnerabilityStatus = search(deviceName);
        Map vulnerabilitStatusEntryCount = search(deviceName);

        ArrayList<String> listOfStrings = (ArrayList<String>) vulnerabilitStatusEntryCount.get("strings");
        ArrayList<Integer> listOfIntegers = (ArrayList<Integer>) vulnerabilitStatusEntryCount.get("integers");

        Log.v(TAG, "listOfStrings: " + listOfStrings.get(0));
        Log.v(TAG, "listOfIntegers: " + listOfIntegers.get(0));

        String vulnerabilityStatus = listOfStrings.get(0);
        Integer entryCount = listOfIntegers.get(0);

        Log.v(TAG, "entryCount: " + entryCount);
        Log.v(TAG, "vulnerabilityStatus: " + vulnerabilityStatus);

        list.add(new DataSearchAroundDevices(deviceName, deviceAddress, vulnerabilityStatus, entryCount));

        adapterSearchAroundDevices = new AdapterSearchAroundDevices(context, list, this);
        recyclerView.setAdapter(adapterSearchAroundDevices);
        adapterSearchAroundDevices.notifyDataSetChanged();


    }

    public Map<String, List> search(String searchText) {

            HashMap<String, List> hashMap = new HashMap<String,List>();
            ArrayList<String> listOfStrings = new ArrayList<String>();
            ArrayList<Integer> listOfIntegers = new ArrayList<Integer>();


            int entryCount = 0;
            int vulnerabilityCount = 0;
            int vulnerabilityCountHolder;

            String vulnerabilityStatus  = "No Vulnerability Detections";

            Log.v("userEntryDatalistsize", String.valueOf(userEntryDatalist.size()));

        for (int i = 0; i < userEntryDatalist.size(); i++) {

            String manufacturermodel = userEntryDatalist.get(i).getManufacturerModel();
//            searchText = "POCOPHONE F1";

            if (manufacturermodel != null) {
                Log.d(TAG, "searchText: " + searchText);


                if (manufacturermodel.toLowerCase().contains(searchText.toLowerCase())) {
                    Log.v(TAG, "match");

                    entryCount+=1;

                    vulnerabilityCountHolder = userEntryDatalist.get(i).getVulnerabilities();
                    vulnerabilityCount += vulnerabilityCountHolder;

                    Log.v(TAG, "vulnerabilityCount: " + vulnerabilityCount);

                }

            } else {
                Log.d("brandmodelname", "empty");
            }
        }

        if (vulnerabilityCount > 0){
            vulnerabilityStatus = "Possible Vulnerability Detections";
        }

        listOfStrings.add(vulnerabilityStatus);
        listOfIntegers.add(entryCount);

        hashMap.put("strings",listOfStrings);
        hashMap.put("integers",listOfIntegers);

        return hashMap;

    }


        /**
         * This method is required for all devices running API23+
         * Android must programmatically check the permissions for bluetooth. Putting the proper permissions
         * in the manifest is not enough.
         *
         * NOTE: This will only execute on versions > LOLLIPOP because it is not needed otherwise.
         */
        @RequiresApi(api = Build.VERSION_CODES.M)

        private void checkBTPermissions(){
            Log.d(TAG, "checkBTPermissions: checking BT Permissions.");

            if (Build.VERSION.SDK_INT > Build.VERSION_CODES.LOLLIPOP) {
                int permissionCheck = 0;
                permissionCheck += this.checkSelfPermission("Manifest.permission.BLUETOOTH");
                permissionCheck += this.checkSelfPermission("Manifest.permission.BLUETOOTH_ADMIN");
                permissionCheck += this.checkSelfPermission("Manifest.permission.ACCESS_FINE_LOCATION");
                permissionCheck += this.checkSelfPermission("Manifest.permission.ACCESS_COARSE_LOCATION");

                if (permissionCheck != 0) {

//                this.requestPermissions(new String[]{Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION}, 1001); //Any number
                    Log.d(TAG, "permissionCheck: !=0 .");
                    this.requestPermissions(new String[]{Manifest.permission.BLUETOOTH, Manifest.permission.BLUETOOTH_ADMIN, Manifest.permission.ACCESS_COARSE_LOCATION, Manifest.permission.ACCESS_FINE_LOCATION}, 1000);
                }
            } else {
                Log.d(TAG, "checkBTPermissions: No need to check permissions. SDK version < LOLLIPOP.");
            }
        }


        @Override
        public void onRequestPermissionsResult ( int requestCode, @NonNull String[] permissions,
                                                 @NonNull int[] grantResults){
            super.onRequestPermissionsResult(requestCode, permissions, grantResults);
            if (requestCode == PERMISSION_CODE) {
                if (grantResults.length > 0) {

                    int grantresultslength = grantResults.length;
                    Log.v(TAG, "" + grantresultslength);

                    for (int i = 0; i < grantresultslength; i++) {

                        if (grantResults[i] == PackageManager.PERMISSION_GRANTED) {

                            Log.v(TAG, "PERMISSION" + i + " GRANTED");


                        } else {
                            Log.v(TAG, "PERMISSION" + i + " DENIED");
                        }
                    }

                } else {
                    Toast.makeText(this, "PERMISSION DENIED", Toast.LENGTH_SHORT).show();
                }
            }
        }
    }


