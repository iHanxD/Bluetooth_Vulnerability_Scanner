package com.example.bluetoothvulnerabilityscanner;

import android.content.Context;
import android.content.Intent;
import android.os.Bundle;

import androidx.annotation.NonNull;
import androidx.fragment.app.Fragment;
import androidx.lifecycle.ViewModelProvider;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import android.os.StrictMode;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;


import com.google.firebase.database.DataSnapshot;
import com.google.firebase.database.DatabaseError;
import com.google.firebase.database.DatabaseReference;
import com.google.firebase.database.FirebaseDatabase;
import com.google.firebase.database.Query;
import com.google.firebase.database.ValueEventListener;

import org.apache.commons.net.time.TimeTCPClient;
import org.w3c.dom.Text;

import java.io.IOException;
import java.sql.Time;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;

///**
// * A simple {@link Fragment} subclass.
// * Use the {@link fragment2#newInstance} factory method to
// * create an instance of this fragment.
// */

public class fragment2 extends Fragment implements ItemAdapter.OnItemListener {


    FirebaseDatabase database = FirebaseDatabase.getInstance("https://bluetoothvulnscannerdb-default-rtdb.asia-southeast1.firebasedatabase.app");
    private DatabaseReference UserEntryDatabase;
    private TimeTCPClient timeTCPClient;
    public String VulnerabilitiesClick;
    public String BaseScoreClick;

    private ScanDevice activity;


    View root;
    Context thiscontext;
    RecyclerView recyclerView;
    TextView resultTitle;
    TextView resultQuantityTitle;
    TextView vulnerabilitiesTitle;
    TextView scoreTitle;

    ItemAdapter itemAdapter;
    ArrayList<ItemData> list;
    ArrayList<String> VulerabilityList;
    ArrayList<String> dupCVEIDList;
    ArrayList<HashMap<String, String>> cveInfo = new ArrayList<HashMap<String, String>>();

    String datetime;
    Integer getDateTimetries = 0;

    String ANDROIDIDEXIST = "FALSE";
    String androidVersionSame = "FALSE";
    String securityPatchSame = "FALSE";
    String cveIndicatorsSame = "FALSE";

    public fragment2() {
        // Required empty public constructor
    }


    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {

        // Inflate the layout for this fragment
        root = inflater.inflate(R.layout.fragment_fragment2, container, false);

        //getting information from ScanDevice activity
        activity = (ScanDevice) getActivity();

        thiscontext = container.getContext();

        recyclerView = root.findViewById(R.id.cveList);
        recyclerView.setHasFixedSize(true);
        recyclerView.setLayoutManager(new LinearLayoutManager(thiscontext));

        //array lists we are going to use
        list = new ArrayList<>();
        VulerabilityList = new ArrayList<>();
        dupCVEIDList = new ArrayList<>();

        //item adapter
        itemAdapter = new ItemAdapter(thiscontext, list, this);
        recyclerView.setAdapter(itemAdapter);

        //database references
        UserEntryDatabase = database.getReference("User_Entry");

        //timeTCP configs
        StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder().permitAll().build();
        StrictMode.setThreadPolicy(policy);
        timeTCPClient = new TimeTCPClient();

        //button finder
        Button scanDeviceButton = (Button) root.findViewById(R.id.scanDevice);

        resultTitle = root.findViewById(R.id.resultTitle);
        resultQuantityTitle = root.findViewById(R.id.resultQuantityTitle);
        vulnerabilitiesTitle = root.findViewById(R.id.vulnerabilitiesTitle);
        scoreTitle = root.findViewById(R.id.scoreTitle);

        VulnerabilitiesClick = "A-Z";
        BaseScoreClick = "High-Low";

        scanDeviceButton.setOnClickListener(new View.OnClickListener() {

            int i = 0;

            @Override
            public void onClick(View view) {

                //counter to see how many times user pressed. they can only press it once.
                if (i == 0) {

                    cveInfo = activity.cveInfo;

                    if (cveInfo.size() > 0) {
                        resultTitle.setText("Vulnerable: YES");
                        resultQuantityTitle.setText("Detected Vulnerabilities: " + String.valueOf(cveInfo.size()));
                        vulnerabilitiesTitle.setText("Vulnerabilities ^");
                        scoreTitle.setText("Base Score ^");


                        for (int i = 0; i < cveInfo.size(); i++) {

                            String cveName = cveInfo.get(i).get("cveName");
                            String baseScore = cveInfo.get(i).get("baseScore");
                            String cveID = cveInfo.get(i).get("cveID");


                            list.add(new ItemData(cveName, baseScore, cveID));
                            VulerabilityList.add(cveID);

                            Log.v("fragment2", cveName + ", " + baseScore);
                            Log.v("fragment2", cveID);
                        }

                    } else {

                        resultTitle.setText("Vulnerable: NO");
                        resultQuantityTitle.setText("Detected Vulnerabilities: " + String.valueOf(cveInfo.size()));

                    }

                    itemAdapter.notifyDataSetChanged();

                    //get current date and time from getdatetime function
                    datetime = getDateTime();

                    //checking if duplicate entry.
                    duplicateChecker();

                    i++;
                }
            }
        });

        TextView Vulnerabilities = (TextView) root.findViewById(R.id.vulnerabilitiesTitle);

        Vulnerabilities.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View view) {

                if (VulnerabilitiesClick.equals("A-Z")) {

                    vulnerabilitiesTitle.setText("Vulnerabilities v");

                    Collections.sort(list, new Comparator<ItemData>() {
                        @Override
                        public int compare(ItemData itemData, ItemData t1) {
                            return itemData.getCveName().compareTo(t1.getCveName());
                        }
                    });

                    itemAdapter.notifyDataSetChanged();

                    VulnerabilitiesClick = "Z-A";


                }else if(VulnerabilitiesClick.equals("Z-A")){

                    vulnerabilitiesTitle.setText("Vulnerabilities ^");

                    Collections.sort(list, new Comparator<ItemData>() {
                        @Override
                        public int compare(ItemData itemData, ItemData t1) {
                            return t1.getCveName().compareTo(itemData.getCveName());
                        }
                    });

                    itemAdapter.notifyDataSetChanged();

                    VulnerabilitiesClick = "A-Z";
                }
            }


        });


        TextView BaseScore = (TextView) root.findViewById(R.id.scoreTitle);

        BaseScore.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View view) {

                if (BaseScoreClick.equals("High-Low")) {

                    scoreTitle.setText("Base Score v");

                    Collections.sort(list, new Comparator<ItemData>() {
                        @Override
                        public int compare(ItemData itemData, ItemData t1) {
                            return itemData.getCvssScore().compareTo(t1.getCvssScore());
                        }
                    });

                    itemAdapter.notifyDataSetChanged();

                    BaseScoreClick = "Low-High";


                }else if(BaseScoreClick.equals("Low-High")){

                    scoreTitle.setText("Base Score ^");

                    Collections.sort(list, new Comparator<ItemData>() {
                        @Override
                        public int compare(ItemData itemData, ItemData t1) {
                            return t1.getCvssScore().compareTo(itemData.getCvssScore());
                        }
                    });

                    itemAdapter.notifyDataSetChanged();

                    BaseScoreClick = "High-Low";
                }
            }


        });



        return root;
    }

    @Override
    public void onItemClick(int position) {

        String cveName = list.get(position).getCveName();
        String cveID = list.get(position).getcveID();

        Log.d("onItemClick", cveName);

        Intent intent = new Intent(thiscontext, CveInfo.class);
        intent.putExtra("cveName", cveName);
        intent.putExtra("cveID", cveID);
        startActivity(intent);

    }

    private void submitUserEntry() {

        //getting information from ScanDevice activity
        activity = (ScanDevice) getActivity();
        cveInfo = activity.cveInfo;

        Log.d("duplicatecheckerafter", ANDROIDIDEXIST + androidVersionSame + securityPatchSame + cveIndicatorsSame);


            String UserEntryDatabaseID = UserEntryDatabase.push().getKey();

            DeviceInfo deviceInfo = new DeviceInfo(activity.ANDROIDID, activity.BOARD, activity.MANUFACTURER, activity.HARDWARE,
                    activity.SOC_MODEL, activity.SOC_MANUFACTURER, activity.FINGERPRINT, activity.DISPLAY, activity.CHIPSET, activity.MODEL,
                    activity.RELEASE, String.valueOf(activity.SDK_INT), activity.SECURITY_PATCH, activity.RADIO, activity.BOOTLOADER,
                    activity.CPUARCHITECTURE, String.valueOf(activity.NUMBEROFCORES), Arrays.toString(activity.SUPPORTED_ABIS), activity.CPUFEATURES);


            UserEntryDatabase.child(UserEntryDatabaseID).setValue(deviceInfo);

            String VulnerabilityBranch = UserEntryDatabaseID + "/vulnerabilities";
            UserEntryDatabase.child(VulnerabilityBranch).setValue(VulerabilityList);

            String DateTimeBranch = UserEntryDatabaseID + "/date";
            UserEntryDatabase.child(DateTimeBranch).setValue(datetime);

            Log.d("UserEntryDatabaseKey", UserEntryDatabaseID);
            Log.d("VulnerabilityBranch", VulnerabilityBranch);


    }

    private String getDateTime() {

        //connect to nist to generate live and more accurate date and time as system date and time
        //may be manipulated

        try {
            timeTCPClient.connect("time.nist.gov");
        } catch (IOException e) {
            e.printStackTrace();
        }

        try {
            datetime = timeTCPClient.getDate().toString();

            Log.d("getDateTime() datetime", datetime);

            return datetime;

        } catch (IOException e) {
            e.printStackTrace();
        }

        if (datetime == null || datetime.length() == 0) {
            getDateTimetries +=1;

            Log.v("getDateTime() tries: ", String.valueOf(getDateTimetries));

            //if date time is unknown, repeat command again until date time is defined.


            //if after 20 tries and still cant get date and time just return datetime as unknown.
            if(getDateTimetries > 20){
                datetime = "unknown";
                return datetime;
            }

            getDateTime();
        }

        return datetime;
    }

    //duplicate checker before submission of user entry to prevent users from spamming database.
    private void duplicateChecker() {

        //getting information from ScanDevice activity
        ScanDevice activity = (ScanDevice) getActivity();
        cveInfo = activity.cveInfo;

        Query firebaseSearchQuery = UserEntryDatabase.orderByChild("androidid").equalTo(activity.ANDROIDID);

        firebaseSearchQuery.addListenerForSingleValueEvent(new ValueEventListener() {
            @Override
            public void onDataChange(@NonNull DataSnapshot snapshot) {

                //if such an android id does not, return false.
                if (!snapshot.exists()) {

                    ANDROIDIDEXIST = "FALSE";
                    Log.d("ANDROIDIDEXIST", "FALSE");

                } else {

                    ANDROIDIDEXIST = "TRUE";
                    Log.d("ANDROIDIDEXIST", "TRUE");

                    for (DataSnapshot ds : snapshot.getChildren()) {

                        String androidVersion = ds.child("release").getValue(String.class);
                        String securityPatch = ds.child("securitypatch").getValue(String.class);

                        //check if same android version
                        if (androidVersion.equals(activity.RELEASE)) {
                            androidVersionSame = "TRUE";
                        }

                        //check if same security patch
                        if (securityPatch.equals(activity.SECURITY_PATCH)) {
                            securityPatchSame = "TRUE";
                        }


                        DataSnapshot vulnerabilities = ds.child("vulnerabilities");

                        //check if vulnerability branch exist
                        if (vulnerabilities.exists()) {

                            //check cveID of all the vulnerabilities. If it does not match, means got new CVE or got patched.

                            dupCVEIDList = new ArrayList<String>();

                            for (DataSnapshot ds2 : vulnerabilities.getChildren()) {

                                if (ds2.exists()) {

                                    String CVEID = ds2.getValue(String.class);
                                    dupCVEIDList.add(CVEID);

                                }

                                //sort both recently scanned device cve IDs array with the database array of CVE IDs
                                Collections.sort(VulerabilityList);
                                Collections.sort(dupCVEIDList);

                                Log.d("VulerabilityList", VulerabilityList.toString());
                                Log.d("dupCVEIDList", dupCVEIDList.toString());


                                if(VulerabilityList.equals(dupCVEIDList)){
                                    cveIndicatorsSame = "TRUE";
                                }
                            }

                        }else{
                            if (VulerabilityList.size() == 0){
                                cveIndicatorsSame = "TRUE";
                            }

                        }
                    }
                }

                Log.d("duplicatecheckerinside", ANDROIDIDEXIST + androidVersionSame + securityPatchSame + cveIndicatorsSame);

                String TrueFalse = "";

                //if androidid doesnt exist, return false
                if (ANDROIDIDEXIST.equals("FALSE")) {
                    TrueFalse += "0";

                }else{
                    TrueFalse += "1";
                }


                //if androidversion is not the same, return false
                if (androidVersionSame.equals("FALSE")) {
                    TrueFalse += "0";
                }else{
                    TrueFalse += "1";
                }

                //if security patch is not the same, return false
                if (securityPatchSame.equals("FALSE")) {
                    TrueFalse += "0";
                }else{
                    TrueFalse += "1";
                }

                //if cve indicators are not the same, return false;
                if (cveIndicatorsSame.equals("FALSE")) {
                    TrueFalse += "0";
                }else{
                    TrueFalse += "1";
                }

                if (!TrueFalse.equals("1111")) {
                    submitUserEntry();
                }
            }


            @Override
            public void onCancelled(@NonNull DatabaseError error) {
                Log.d("fragment2", "DATABASE ERROR", error.toException());
            }
        });

    }


}

