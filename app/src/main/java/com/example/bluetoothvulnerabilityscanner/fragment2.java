package com.example.bluetoothvulnerabilityscanner;

import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.os.Bundle;

//rayhan was here

import androidx.annotation.NonNull;
import androidx.fragment.app.Fragment;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;


import com.google.firebase.auth.FirebaseAuth;
import com.google.firebase.auth.FirebaseUser;
import com.google.firebase.database.DataSnapshot;
import com.google.firebase.database.DatabaseError;
import com.google.firebase.database.DatabaseReference;
import com.google.firebase.database.FirebaseDatabase;
import com.google.firebase.database.Query;
import com.google.firebase.database.ServerValue;
import com.google.firebase.database.ValueEventListener;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;

///**
// * A simple {@link Fragment} subclass.
// * Use the {@link fragment2#newInstance} factory method to
// * create an instance of this fragment.
// */

public class fragment2 extends Fragment implements AdapterCve.OnItemListener {

    final String TAG = "Fragment2";

    FirebaseDatabase database = FirebaseDatabase.getInstance("https://bluetoothvulnscannerdb-default-rtdb.asia-southeast1.firebasedatabase.app");
    private DatabaseReference UserScanResultDatabase ;
    private DatabaseReference CHIPSETDatabase = database.getReference("Chipsets");
    private DatabaseReference IOCDatabase = database.getReference("IOC");
    private DatabaseReference CVEDatabase = database.getReference("CVE");

    public String VulnerabilitiesClick;
    public String BaseScoreClick;
    private ScanDevice activity;

    View root;
    Context thiscontext;
    RecyclerView recyclerView;
    TextView resultTitle;
    TextView resultQuantityTitle;
    TextView vulnerabilitiesTitle;
    TextView scoreTitle;
    TextView statusValue;

    AdapterCve adapterCve;
    ArrayList<DataCve> list;
    ArrayList<String> VulerabilityList;
    ArrayList<String> dupCVEIDList;
    ArrayList<HashMap<String, String>> cveInfo = new ArrayList<HashMap<String, String>>();

    String ANDROIDIDEXIST = "FALSE";
    String androidVersionSame = "FALSE";
    String securityPatchSame = "FALSE";
    String cveIndicatorsSame = "FALSE";
    String scanStatus = "Not Scanned";



    //defining calls and counts
    int scanDeviceFunctionCalls = 0;
    int cveIDArrayCompilerCount = 0;

    public ArrayList<String> cveIDArray = new ArrayList<String>();
    public ArrayList<String> cveIDArrayHolder = new ArrayList<String>();


    public fragment2() {
        // Required empty public constructor
    }


    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {

        // Inflate the layout for this fragment
        root = inflater.inflate(R.layout.fragment_fragment2, container, false);

        //getting information from ScanDevice activity
        activity = (ScanDevice) getActivity();

        thiscontext = container.getContext();

        recyclerView = root.findViewById(R.id.cveList);
        recyclerView.setHasFixedSize(true);
        recyclerView.setLayoutManager(new LinearLayoutManager(thiscontext));

        //array lists we are going to use
        list = new ArrayList<>();
        VulerabilityList = new ArrayList<>();
        dupCVEIDList = new ArrayList<>();

        //item adapter
        adapterCve = new AdapterCve(thiscontext, list, this);
        recyclerView.setAdapter(adapterCve);

        //button finder
        Button scanDeviceButton = (Button) root.findViewById(R.id.scanDevice);

        resultTitle = root.findViewById(R.id.resultTitle);
        resultQuantityTitle = root.findViewById(R.id.resultQuantityTitle);
        vulnerabilitiesTitle = root.findViewById(R.id.vulnerabilitiesTitle);
        scoreTitle = root.findViewById(R.id.scoreTitle);
        statusValue = root.findViewById(R.id.statusValue);
        statusValue.setText(scanStatus);

        VulnerabilitiesClick = "A-Z";
        BaseScoreClick = "High-Low";

        scanDeviceButton.setOnClickListener(new View.OnClickListener() {

            int r = 0;
            @Override
            public void onClick(View view) {

                FirebaseUser user = FirebaseAuth.getInstance().getCurrentUser();
                Log.v("user", String.valueOf(user));

                //if user not logged in,
                if (user == null) {
                    showLoginAlertDialog();

                } else {

                    boolean emailVerified = user.isEmailVerified();
                    //dont allow user to scan if email not verified!
                    if (!emailVerified) {
                        showEmailVerify();
                    } else {

                    // The user's ID, unique to the Firebase project. Do NOT use this value to
                    // authenticate with your backend server, if you have one. Use
                    // FirebaseUser.getIdToken() instead.
                    String uid = user.getUid();

                    //database reference. It will create the the branch when pushing later if it does not exist.
                    UserScanResultDatabase = database.getReference("Users").child(uid).child("/scanresults");

                    if (r > 0) {
                        Toast.makeText(thiscontext, "You already scanned!", Toast.LENGTH_SHORT).show();
                    }

                    if (scanStatus.equals("Not Scanned")) {
                        scanStatus = "Loading...";
                        statusValue.setText(scanStatus);
                        scanStatus = "LoadingTextFinished";
                        Log.v("statusValue", scanStatus);
                    }

                    //counter to see how many times user pressed. they can only press it once per time they enter scan device activity.
                    if (r == 0) {

                        if (scanStatus.equals("LoadingTextFinished")) {

                            scanStatus = "Finished Scan";

                            String BOARD_REPLACEMENT = activity.BOARD;
                            String SOC_MODEL_REPLACEMENT = activity.SOC_MODEL;
                            String RELEASE_REPLACEMENT = activity.RELEASE;

                            if (BOARD_REPLACEMENT.equals(null)) {BOARD_REPLACEMENT = "unknown";}
                            if (SOC_MODEL_REPLACEMENT.equals(null)) {SOC_MODEL_REPLACEMENT = "unknown";}
                            if (RELEASE_REPLACEMENT.equals(null)) {RELEASE_REPLACEMENT = "unknown";}

                            firebaseChipset(BOARD_REPLACEMENT);
                            Log.d("firebaseChipset", "Done " + BOARD_REPLACEMENT);


                            //only for android versions 12 as we can get the SOC_MODEL directly.
                            if (activity.SDK_INT >= 31) {
                                firebaseSOC(SOC_MODEL_REPLACEMENT);
                                Log.d("firebaseSOCMODEL", "Done " + activity.SOC_MODEL);
                            } else {
                                //if android is not version 12++, BOARD should indicate the SOC the device is using.
                                firebaseSOC(BOARD_REPLACEMENT);
                            }

                            Integer dotzerochecker = RELEASE_REPLACEMENT.indexOf(".0");

                            //if RELEASE version already has a ".0" This means the release may be 8.0 or 8.1.0. If it is 8.1.0, it will be a problem as
                            //it is more known as android 8.1 and database also stores it as 8.1. To prevent  inssues, we will remove the ".0". This will
                            //also change the normal 8.0 to a flat 8. This does not matter as in the next part, we will add it back.

                            if(dotzerochecker != -1){
                                Log.d(TAG, ".0 found " + dotzerochecker);
                                int length = RELEASE_REPLACEMENT.length();
                                RELEASE_REPLACEMENT = RELEASE_REPLACEMENT.substring(0,  length - 2);
                                Log.d(TAG, "RELEASE_REPLACEMENT new value: " + RELEASE_REPLACEMENT);
                            }


                            Integer dotchecker = RELEASE_REPLACEMENT.indexOf(".");

                            //if RELEASE version does not have a "." This means the release is a flat number like 9, 10, 11. We need to add
                            // the .0 at the end to ensure the version is correct. In the database it is stored as 12.0 and not just 12.
                            if (dotchecker == -1) {
                                Log.d(TAG, "dot not found " + dotchecker);
                                RELEASE_REPLACEMENT = RELEASE_REPLACEMENT + ".0";
                            }


                            firebaseAndroidOS(RELEASE_REPLACEMENT);
                            Log.d("firebaseRELEASE", "Done " + RELEASE_REPLACEMENT);

                            r++;
                        }
                    }
                }
            }
            }
        });

        TextView Vulnerabilities = (TextView) root.findViewById(R.id.vulnerabilitiesTitle);

        Vulnerabilities.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View view) {

                if (VulnerabilitiesClick.equals("A-Z")) {

                    vulnerabilitiesTitle.setText("Vulnerabilities v");

                    Collections.sort(list, new Comparator<DataCve>() {
                        @Override
                        public int compare(DataCve dataCve, DataCve t1) {
                            return dataCve.getCveName().compareTo(t1.getCveName());
                        }
                    });

                    adapterCve.notifyDataSetChanged();

                    VulnerabilitiesClick = "Z-A";


                }else if(VulnerabilitiesClick.equals("Z-A")){

                    vulnerabilitiesTitle.setText("Vulnerabilities ^");

                    Collections.sort(list, new Comparator<DataCve>() {
                        @Override
                        public int compare(DataCve dataCve, DataCve t1) {
                            return t1.getCveName().compareTo(dataCve.getCveName());
                        }
                    });

                    adapterCve.notifyDataSetChanged();

                    VulnerabilitiesClick = "A-Z";
                }
            }


        });


        TextView BaseScore = (TextView) root.findViewById(R.id.scoreTitle);

        BaseScore.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View view) {

                if (BaseScoreClick.equals("High-Low")) {

                    scoreTitle.setText("Base Score v");

                    Collections.sort(list, new Comparator<DataCve>() {
                        @Override
                        public int compare(DataCve dataCve, DataCve t1) {
                            return dataCve.getCvssScore().compareTo(t1.getCvssScore());
                        }
                    });

                    adapterCve.notifyDataSetChanged();

                    BaseScoreClick = "Low-High";


                }else if(BaseScoreClick.equals("Low-High")){

                    scoreTitle.setText("Base Score ^");

                    Collections.sort(list, new Comparator<DataCve>() {
                        @Override
                        public int compare(DataCve dataCve, DataCve t1) {
                            return t1.getCvssScore().compareTo(dataCve.getCvssScore());
                        }
                    });

                    adapterCve.notifyDataSetChanged();

                    BaseScoreClick = "High-Low";
                }
            }


        });
        return root;

    }

    @Override
    public void onItemClick(int position) {

        String cveName = list.get(position).getCveName();
        String cveID = list.get(position).getcveID();

        Log.d("onItemClick", cveName);

        Intent intent = new Intent(thiscontext, CveInfo.class);
        intent.putExtra("cveName", cveName);
        intent.putExtra("cveID", cveID);
        startActivity(intent);

    }

    private void submitUserEntry(ArrayList<HashMap<String, String>> cveInfo) {

        //getting information from ScanDevice activity
        activity = (ScanDevice) getActivity();
//        cveInfo = activity.cveInfo;

        Log.d("duplicatecheckerafter", ANDROIDIDEXIST + androidVersionSame + securityPatchSame + cveIndicatorsSame);

            String ScanResultID = UserScanResultDatabase.push().getKey();

            DataDeviceInfo dataDeviceInfo = new DataDeviceInfo(activity.ANDROIDID, activity.BOARD, activity.MANUFACTURER, activity.HARDWARE,
                    activity.SOC_MODEL, activity.SOC_MANUFACTURER, activity.FINGERPRINT, activity.DISPLAY, activity.CHIPSET, activity.MODEL,
                    activity.RELEASE, String.valueOf(activity.SDK_INT), activity.SECURITY_PATCH, activity.RADIO, activity.BOOTLOADER,
                    activity.CPUARCHITECTURE, String.valueOf(activity.NUMBEROFCORES), Arrays.toString(activity.SUPPORTED_ABIS), activity.CPUFEATURES);


        UserScanResultDatabase.child(ScanResultID).setValue(dataDeviceInfo);

            String VulnerabilityBranch = ScanResultID + "/vulnerabilities";
        UserScanResultDatabase.child(VulnerabilityBranch).setValue(VulerabilityList);

            String DateTimeBranch = ScanResultID + "/date";
        //get the server to input the timestamp of when it is processing the query
        // this is to get a more accurate date and time as system date and time
        // as users may be manipulated local datetime
        UserScanResultDatabase.child(DateTimeBranch).setValue(ServerValue.TIMESTAMP);


            Log.d("UserEntryDatabaseKey", ScanResultID);
            Log.d("VulnerabilityBranch", VulnerabilityBranch);


    }

    //duplicate checker before submission of user entry to prevent users from spamming database.
    private void duplicateChecker(ArrayList<HashMap<String, String>> cveInfo) {

        //getting information from ScanDevice activity
        ScanDevice activity = (ScanDevice) getActivity();

        //query database for androidid.
        Query firebaseSearchQuery = UserScanResultDatabase.orderByChild("androidid").equalTo(activity.ANDROIDID);

        firebaseSearchQuery.addListenerForSingleValueEvent(new ValueEventListener() {
            @Override
            public void onDataChange(@NonNull DataSnapshot snapshot) {
                //if such an android id does not exist, set value false.
                if (!snapshot.exists()) {
                    ANDROIDIDEXIST = "FALSE";
                    Log.d("ANDROIDIDEXIST", "FALSE");
                } else {

                    //if it exists, set value as true
                    ANDROIDIDEXIST = "TRUE";
                    Log.d("ANDROIDIDEXIST", "TRUE");

                    for (DataSnapshot ds : snapshot.getChildren()) {

                        String androidVersion = ds.child("release").getValue(String.class);
                        String securityPatch = ds.child("securitypatch").getValue(String.class);

                        //check if same android version. if it is, set true
                        if (androidVersion.equals(activity.RELEASE)) {
                            androidVersionSame = "TRUE";
                        }

                        //check if same security patch. if it is, set true
                        if (securityPatch.equals(activity.SECURITY_PATCH)) {
                            securityPatchSame = "TRUE";
                        }

                        DataSnapshot vulnerabilities = ds.child("vulnerabilities");

                        //check if vulnerability branch exist
                        if (vulnerabilities.exists()) {

                            //check cveID of all the vulnerabilities. If it does not match, means got new CVE or got patched.
                            dupCVEIDList = new ArrayList<String>();

                            for (DataSnapshot ds2 : vulnerabilities.getChildren()) {

                                if (ds2.exists()) {
                                    String CVEID = ds2.getValue(String.class);
                                    dupCVEIDList.add(CVEID);
                                }

                                //sort both recently scanned device cve IDs array with the database array of CVE IDs
                                Collections.sort(VulerabilityList);
                                Collections.sort(dupCVEIDList);

                                Log.d("VulerabilityList", VulerabilityList.toString());
                                Log.d("dupCVEIDList", dupCVEIDList.toString());

                                //compare the current vulnerability list with the vulnerability list on firebase.
                                if(VulerabilityList.equals(dupCVEIDList)){
                                    //if same, set as true
                                    cveIndicatorsSame = "TRUE";
                                }
                            }
                        }else{
                            //if snapshot ds2 doesnt exist, means vulnerability list on database doesnt exist and
                            //means no vulnerabilities

                            //if the vulnerability list also empty,
                            if (VulerabilityList.size() == 0){

                                //set as true
                                cveIndicatorsSame = "TRUE";
                            }
                        }
                    }
                }

                Log.d("duplicatecheckerinside", ANDROIDIDEXIST + androidVersionSame + securityPatchSame + cveIndicatorsSame);

                String TrueFalse = "";
                int TrueFalseValue = 0;

                //if androidid doesnt exist, return false
                if (ANDROIDIDEXIST.equals("FALSE")) {TrueFalseValue += 0;}else{TrueFalseValue += 1;}

                //if androidversion is not the same, return false
                if (androidVersionSame.equals("FALSE")) {TrueFalseValue += 0;}else{TrueFalseValue += 1;}

                //if security patch is not the same, return false
                if (securityPatchSame.equals("FALSE")) {TrueFalseValue += 0;}else{TrueFalseValue += 1;}

                //if cve indicators are not the same, return false;
                if (cveIndicatorsSame.equals("FALSE")) {TrueFalseValue += 0;}else{TrueFalseValue += 1;}

                //if the truefalsevalue not equal to 4, means one of the parameter check is not the same as the
                //firebase database value. Means just scanned user vulnearbility status reports is different
                //and hence, allow user to post a the user report
                if (TrueFalseValue!=4) {submitUserEntry(cveInfo);}
            }


            @Override
            public void onCancelled(@NonNull DatabaseError error) {
                Log.d("fragment2", "DATABASE ERROR", error.toException());
            }
        });

    }

    private void showLoginAlertDialog(){
        //Setup the alert builder
        AlertDialog.Builder builder = new AlertDialog.Builder(thiscontext);
        builder.setTitle("Not Logged In");
        builder.setMessage("Please create an account or log in to scan device.");

        //Redirect to login page if user clicks on log in button
        builder.setPositiveButton("Log In", new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialogInterface, int id) {
                Intent intent = new Intent(thiscontext, LoginPage.class);
                thiscontext.startActivity(intent);
                activity.finish();
            }
        });

        //create the alert dialog
        AlertDialog alertDialog = builder.create();

        //show the alert dialog
        alertDialog.show();

    }


    private void showEmailVerify(){
        //Setup the alert builder
        AlertDialog.Builder builder = new AlertDialog.Builder(thiscontext);
        builder.setTitle("Email not verified!");
        builder.setMessage("Please verify email first!");

        //Redirect to home page if user clicks on home text
        builder.setPositiveButton("Home", new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialogInterface, int id) {
                Intent intent = new Intent(thiscontext, MainActivity.class);
                intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP| Intent.FLAG_ACTIVITY_NEW_TASK);
                startActivity(intent);
                activity.finish();

            }
        });

        //create the alert dialog
        AlertDialog alertDialog = builder.create();

        //show the alert dialog
        alertDialog.show();

    }




    //This method is to search the Chipset database for the Bluetooth combo wireless SoC model of the device's chipset if any
    private void firebaseChipset(String boardText) {

        Query firebaseSearchQuery = CHIPSETDatabase.orderByChild("Chipset").equalTo(boardText);
        firebaseSearchQuery.addListenerForSingleValueEvent(new ValueEventListener() {

            @Override
            public void onDataChange(@NonNull DataSnapshot snapshot) {

                //defining btsoc as a placeholder
                String btsoc = "";

                if (snapshot.exists()) {

                    for (DataSnapshot ds : snapshot.getChildren()) {

                        //replacing the btsoc value from the returned datasnapshot
                        btsoc = ds.child("Bluetooth SOC").getValue(String.class);

                    }
                    Log.d(TAG, "btsoc: " + btsoc);

                } else {
                    Log.d(TAG, "firebaseChipset: No data found");
                }


                //run next function to search for CVE with the BlueTooth SOC of the chipset as its IOC.
                firebaseBTSOC(btsoc);
                Log.v("tropp : firebaseChipset", String.valueOf(scanDeviceFunctionCalls));
            }

            @Override
            public void onCancelled(@NonNull DatabaseError error) {
                Log.d("ScanDevice", "DATABASE ERROR", error.toException());
            }
        });

    }



    //This method is to search the IOC database for the Bluetooth combo wireless SoC model of the chipset
    private void firebaseBTSOC(String finalbtsoc) {
        Query firebaseSearchQuery = IOCDatabase.orderByChild("SOC").equalTo(finalbtsoc);
        Log.d("fragment1", "finalbtsoc: " + finalbtsoc);

        firebaseSearchQuery.addListenerForSingleValueEvent(new ValueEventListener() {
            @Override
            public void onDataChange(@NonNull DataSnapshot snapshot) {

                //creation of array list to store data.
                cveIDArray = new ArrayList<String>();

                if (snapshot.exists()) {

                    //get the main branch values.
                    for (DataSnapshot ds : snapshot.getChildren()) {
                        //to get values of each CVE ID in the CVE Related branch which is the child of the main branch.
                        DataSnapshot cveid = ds.child("CVE_ID_Related");

                        //for each child of the CVE Related branch,
                        for (DataSnapshot ds2 : cveid.getChildren()) {
                            Log.v("getKey", "getkeyds2: " + ds2.getKey()); //displays the key for the node
                            Log.v("child", "getvalueds2: " + ds2.getValue());   //gives the value for each children
                            cveIDArray.add(String.valueOf(ds2.getValue()));
                        }
                    }
                } else {
                    Log.d(TAG, "firebaseBTSOC: No data found");
                }
                scanDeviceFunctionCalls += 1;
                cveIDArrayCompiler(cveIDArray);
                Log.v("tropp : firebaseBTSOC", String.valueOf(scanDeviceFunctionCalls));
            }
            @Override
            public void onCancelled(@NonNull DatabaseError error) {
                Log.d("ScanDevice", "DATABASE ERROR", error.toException());
            }
        });
    }

    //    //This method is to search the IOC database for the SoC model/chipset of the device.
    private void firebaseSOC(String SOCValue) {
        Log.v(TAG, "firebaseSOC: " + SOCValue); //displays the key for the node

        Query firebaseSearchQuery = IOCDatabase.orderByChild("SOC").equalTo(SOCValue);
        firebaseSearchQuery.addListenerForSingleValueEvent(new ValueEventListener() {

            @Override
            public void onDataChange(@NonNull DataSnapshot snapshot) {

                cveIDArray = new ArrayList<String>();
                if (snapshot.exists()) {
                    Log.v(TAG, "firebaseSOC: snapshot exist"); //displays the key for the node
                    for (DataSnapshot ds : snapshot.getChildren()) {

                        DataSnapshot cveid = ds.child("CVE_ID_Related");
                        for (DataSnapshot ds2 : cveid.getChildren()) {

                            Log.v("getKey", "getkeyds2: " + ds2.getKey()); //displays the key for the node
                            Log.v("child", "getvalueds2: " + ds2.getValue());   //gives the value for each children
                            cveIDArray.add(String.valueOf(ds2.getValue()));
                        }
                    }
                } else {
                    Log.d(TAG, "firebaseSOC: No data found");
                }
                scanDeviceFunctionCalls += 1;
                cveIDArrayCompiler(cveIDArray);
                Log.v("tropp : firebaseSOC", String.valueOf(scanDeviceFunctionCalls));
            }

            @Override
            public void onCancelled(@NonNull DatabaseError error) {
                Log.d(TAG, "DATABASE ERROR", error.toException());
            }
        });

    }


    //This method is to search the IOC database for the SoC model/chipset of the device.
    private void firebaseAndroidOS(String AndroidOS) {
        Log.v(TAG, "firebaseAndroidOS: " + AndroidOS);

        Query firebaseSearchQuery = IOCDatabase.orderByChild("AndroidOS").equalTo(AndroidOS);
        firebaseSearchQuery.addListenerForSingleValueEvent(new ValueEventListener() {

            @Override
            public void onDataChange(@NonNull DataSnapshot snapshot) {
                cveIDArray = new ArrayList<String>();
                if (snapshot.exists()) {
                    Log.v(TAG, "firebaseSOC: snapshot exist"); //displays the key for the node

                    for (DataSnapshot ds : snapshot.getChildren()) {

                        DataSnapshot cveid = ds.child("CVE_ID_Related");

                        for (DataSnapshot ds2 : cveid.getChildren()) {
                            Log.v("getKey", "getkeyds2: " + ds2.getKey()); //displays the key for the node
                            Log.v("child", "getvalueds2: " + ds2.getValue());   //gives the value for each children
                            cveIDArray.add(String.valueOf(ds2.getValue()));
                        }
                    }

                } else {
                    Log.d(TAG, "firebaseAndroidOS: No data found");
                }
                scanDeviceFunctionCalls += 1;
                cveIDArrayCompiler(cveIDArray);
                Log.v("tropp : fbAndroidOS", String.valueOf(scanDeviceFunctionCalls));
            }
            @Override
            public void onCancelled(@NonNull DatabaseError error) {
                Log.d(TAG, "DATABASE ERROR", error.toException());
            }
        });
    }


    //this function compiles the arrays filled up from the previous 3 functions. This is because onData does not save data outside
    //of the function. By calling this function inside the the previous functions, it will append the values in the array and save
    //it as a whole array.
    private void cveIDArrayCompiler(ArrayList<String> cveIDArray) {

        cveIDArrayCompilerCount += 1;

        for (int i = 0; i < cveIDArray.size(); i++) {

            String cveID = cveIDArray.get(i);
            cveIDArrayHolder.add(cveID);

            Log.v(TAG, "cveIDArrayCompiler: " + cveID);
        }


        Log.v(TAG, "cveIDArrayCompilerCount: " + cveIDArrayCompilerCount);
        Log.v(TAG, "scanDeviceFunctionCalls: " + scanDeviceFunctionCalls);

        //this is to make sure the array is filled up by the previous 3 functions. the value scanDeviceFunctionCalls is incremented
        //by 1 after each function runs.
        if (scanDeviceFunctionCalls == 3) {
            firebaseSearchCVEByID(new FirebaseCallback(){
                @Override
                public void onCallback(ArrayList<HashMap<String, String>> list) {
                    Log.v(TAG, "I AM HERE " + list.size());

                    //call to display on screen the cve and also submit the user entry
                    displayAndSubmit();

                }
            });
        }
    }




    //this method is to search the CVE database for the ID given by previous methods.
    private void firebaseSearchCVEByID(FirebaseCallback firebaseCallback){

        HashMap<String, Integer> cveFrequencyMap = new HashMap<String, Integer>();

        for (int i = 0; i < cveIDArrayHolder.size(); i++) {
            String cveID = cveIDArrayHolder.get(i);
            //counter for each cveid.
            if (cveFrequencyMap.containsKey(cveID)) {
                cveFrequencyMap.put(cveID, cveFrequencyMap.get(cveID) + 1);
            } else {
                cveFrequencyMap.put(cveID, 1);
            }
            Log.v("cveIDArray", "" + cveID);
        }

        final int[] i = {0};
        int cveFrequencyMapSize = cveFrequencyMap.size();
        for (Map.Entry<String, Integer> entry : cveFrequencyMap.entrySet()) {

            String cveID = entry.getKey();
            Integer count = entry.getValue();

            Query firebaseSearchQuery = CVEDatabase.orderByChild("ID").equalTo(cveID);
            firebaseSearchQuery.addListenerForSingleValueEvent(new ValueEventListener() {
                @Override
                public void onDataChange(@NonNull DataSnapshot snapshot) {

                    Log.v("onDataChange", "onDataChange SUCCESS");
                    if (snapshot.exists()) {

                        HashMap<String, String> informationHolder = new HashMap<String, String>();

                        for (DataSnapshot ds : snapshot.getChildren()) {

                            Log.v(TAG,"CVEIDSEARCH: " + ds.getKey());
                            informationHolder = new HashMap<String, String>();
                            String cveID = ds.child("ID").getValue(String.class);
                            Integer cveCountRequired = ds.child("countRequired").getValue(Integer.class);
                            informationHolder.put("cveID", cveID);
                            String cveName = ds.getKey();
                            informationHolder.put("cveName", cveName);
                            Log.v("cveFrequencyMap: ", cveID + " " + cveName + " " + count);

                            DataSnapshot cvss = ds.child("CVSS");
                            for (DataSnapshot ds2 : cvss.getChildren()) {

                                String key = ds2.getKey();
                                String value = String.valueOf(ds2.getValue());

                                //only want the score for now

                                if (key.equals("Base Score")) {
                                    //only want the value of the front
                                    String baseScore = value.substring(0, 4);
                                    Log.v("child", "getvalueds3: " + baseScore);   //gives the value for each children
                                    informationHolder.put("baseScore", baseScore);
                                }
                                Log.v(TAG, "getkeyds3: " + ds2.getKey()); //displays the key for the node
                            }

                            //only if the count matches, add the cveinfo into the array. This is to ensure the device has hit
                            //2 or more IOCs as some CVEs require 2 IOCs to be considered vulnerable.

                            if (cveCountRequired == count) {
                                cveInfo.add(informationHolder);
                                Log.d(TAG, "cveCountRequired: matched. " + cveCountRequired + ":" + cveFrequencyMap.get(cveID) + "  " + cveName);

                            } else if (cveCountRequired > cveFrequencyMap.get(cveID)) {
                                Log.d(TAG, "cveCountRequired greater. Not enough counts. " + cveCountRequired + ":" + cveFrequencyMap.get(cveID) + "  " + cveName);

                            } else {
                                Log.d(TAG, "cveCountRequired smaller. Possible function errors. " + cveCountRequired + ":" + cveFrequencyMap.get(cveID) + "  " + cveName);
                            }
                        }
                    } else {
                        Log.d(TAG, "No data found");
                    }

                    i[0]++;
                    if(i[0] == cveFrequencyMapSize) {
                        firebaseCallback.onCallback(cveInfo);
                    }
                }

                @Override
                public void onCancelled(@NonNull DatabaseError error) {
                    Log.d(TAG, "DATABASE ERROR", error.toException());
                }
            });
        }
    }

    private interface FirebaseCallback{
        void onCallback(ArrayList<HashMap<String, String>> cveInfo);
    }


    private void displayAndSubmit(){

        if (cveInfo.size() > 0) {
            statusValue.setText(scanStatus);
            resultTitle.setText("Vulnerable: YES");
            resultQuantityTitle.setText("Count: " + String.valueOf(cveInfo.size()));
            vulnerabilitiesTitle.setText("Vulnerabilities ^");
            scoreTitle.setText("Base Score ^");


            //to add cve info into each cve item
            for (int i = 0; i < cveInfo.size(); i++) {

                String cveName = cveInfo.get(i).get("cveName");
                String baseScore = cveInfo.get(i).get("baseScore");
                String cveID = cveInfo.get(i).get("cveID");


                list.add(new DataCve(cveName, baseScore, cveID));
                VulerabilityList.add(cveID);

                Log.v("fragment2", cveName + ", " + baseScore);
                Log.v("fragment2", cveID);
            }

        } else {
            statusValue.setText(scanStatus);
            resultTitle.setText("Vulnerable: NO");
            resultQuantityTitle.setText("Count: " + String.valueOf(cveInfo.size()));
        }

        adapterCve.notifyDataSetChanged();

        //checking if duplicate entry.
        duplicateChecker(cveInfo);

    }




}

