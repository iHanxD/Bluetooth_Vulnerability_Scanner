package com.example.bluetoothvulnerabilityscanner;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;
import androidx.fragment.app.FragmentPagerAdapter;
import androidx.viewpager.widget.ViewPager;

import android.os.Build;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.TableLayout;
import android.widget.TextView;
import android.widget.Toast;


import com.google.android.gms.tasks.OnCompleteListener;
import com.google.android.gms.tasks.OnFailureListener;
import com.google.android.gms.tasks.OnSuccessListener;
import com.google.android.gms.tasks.Task;
import com.google.android.material.tabs.TabLayout;
import com.google.firebase.database.DataSnapshot;
import com.google.firebase.database.DatabaseError;
import com.google.firebase.database.DatabaseReference;
import com.google.firebase.database.FirebaseDatabase;
import com.google.firebase.database.Query;
import com.google.firebase.database.ValueEventListener;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileFilter;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Pattern;

public class ScanDevice extends AppCompatActivity {

    private TabLayout tabLayout;
    private ViewPager viewPager;

    public String myString = "hello";


//    //defining variables
//    TextView modelValue;
//    TextView manufacturerValue;
//    TextView basebandValue;
//    TextView buildnumberValue;
//    TextView buildfingerprintValue;
//    TextView bootloaderValue;
//    TextView osversionValue;
//    TextView sdkValue;
//
//    TextView testingValue;
//
//    Build build;
//    Build.VERSION version;
//    Build.Partition partition;
//    String information;
//    String boardText;
//    String finalbtsoc;
//    String output;
//
//    private Button scanDeviceButton;
//    private DatabaseReference IOCDatabase;
//    private DatabaseReference CHIPSETDatabase;
//
////    private static final String TAG = "Build";
//
//    /** Value used for when a build property is unknown. */
//    public static final String UNKNOWN = "unknown";
//
//    /** Either a changelist number, or a label like "M4-rc20". */
//    public final String ID = build.ID;
//
//    /** A build ID string meant for displaying to the user */
//    public final String DISPLAY = build.DISPLAY;
//
//    /** The name of the overall product. */
//    public final String PRODUCT = build.PRODUCT;
//
//    /** The name of the industrial design. */
//    public final String DEVICE = build.DEVICE;
//
//    /** The name of the underlying board, like "goldfish". */
//    public final String BOARD = build.BOARD;
//
//    /** The end-user-visible name for the end product. */
//    public final String MODEL = build.MODEL;
//
//    /** The manufacturer of the product/hardware. */
//    public final String MANUFACTURER = build.MANUFACTURER;
//
//    /** The consumer-visible brand with which the product/hardware will be associated, if any. */
//    public final String BRAND = build.BRAND;
//
//    /** Device Fingerprint*/
//    public final String FINGERPRINT = build.FINGERPRINT;
//
//    /** The system bootloader version number. */
//    public final String BOOTLOADER = build.BOOTLOADER;
//
//    /** The name of the hardware (from the kernel command line or /proc). */
//    public final String HARDWARE = build.HARDWARE;
//
//    /** The name of the radio/baseband */
//    public final String RADIO = build.getRadioVersion();
//
//    public final String RELEASE = version.RELEASE;
//
//    public final String BASE_OS   = version.BASE_OS ;
//
//    public final String SECURITY_PATCH = version.SECURITY_PATCH;
//
//    public final int PREVIEW_SDK_INT = version.PREVIEW_SDK_INT;
//
//    public final int SDK_INT = version.SDK_INT;
//
//    public final String CODENAME  = version.CODENAME;
//
//    public final String PARTITION_NAME_SYSTEM = partition.PARTITION_NAME_SYSTEM;
//
//    public final String SERIAL  = build.SERIAL;
//
//    public final String SUPPORTED_32_BIT_ABIS[] = build.SUPPORTED_32_BIT_ABIS;
//
//    public final String SUPPORTED_64_BIT_ABIS[] = build.SUPPORTED_64_BIT_ABIS;
//
//    public final String SUPPORTED_ABIS[] = build.SUPPORTED_ABIS;
//
//
//    //These variables are declared as unknown first as they are only available on API levels 31 and above
//    //Only if the device is of API level 31 will the scanner search for these values.
//    /** The model name of the device's primary system-on-chip. */
//    public String SOC_MODEL  = UNKNOWN;
//
//    public String SOC_MANUFACTURER  = UNKNOWN;
//
//    /** The SKU of the hardware (from the kernel command line) */
//    public String SKU = UNKNOWN;
//
//    /** The SKU of the device as set by the original design manufacturer (ODM) */
//    public String ODM_SKU = UNKNOWN;
//
//    public String RELEASE_OR_CODENAME = UNKNOWN;

    //defining variables

    String boardText;
    String finalbtsoc;
    String output;

    Map<String, String> cpuinfo = new HashMap<String, String>();

    Build build;
    Build.VERSION version;
    Build.Partition partition;
    String information;
    //    String cpupresent;
//    String cpupossible;


    ArrayList<String> cveIDArray = new ArrayList<String>();
    public ArrayList<HashMap<String, String>> cveInfo = new ArrayList<HashMap<String, String>>();
//    public ArrayList<String> cveInfo = new ArrayList<>();


    private DatabaseReference IOCDatabase;
    private DatabaseReference CHIPSETDatabase;
    private DatabaseReference CVEDatabase;


//    private static final String TAG = "Build";

    /**
     * Value used for when a build property is unknown.
     */
    public static final String UNKNOWN = "unknown";

    /**
     * Either a changelist number, or a label like "M4-rc20".
     */
    public final String ID = build.ID;

    /**
     * A build ID string meant for displaying to the user
     */
    public final String DISPLAY = build.DISPLAY;

    /**
     * The name of the overall product.
     */
    public final String PRODUCT = build.PRODUCT;

    /**
     * The name of the industrial design.
     */
    public final String DEVICE = build.DEVICE;

    /**
     * The name of the underlying board, like "goldfish".
     */
    public final String BOARD = build.BOARD;

    /**
     * The end-user-visible name for the end product.
     */
    public final String MODEL = build.MODEL;

    /**
     * The manufacturer of the product/hardware.
     */
    public final String MANUFACTURER = build.MANUFACTURER;

    /**
     * The consumer-visible brand with which the product/hardware will be associated, if any.
     */
    public final String BRAND = build.BRAND;

    /**
     * Device Fingerprint
     */
    public final String FINGERPRINT = build.FINGERPRINT;

    /**
     * The system bootloader version number.
     */
    public final String BOOTLOADER = build.BOOTLOADER;

    /**
     * The name of the hardware (from the kernel command line or /proc).
     */
    public final String HARDWARE = build.HARDWARE;

    /**
     * The name of the radio/baseband
     */
    public final String RADIO = build.getRadioVersion();

    public final String RELEASE = version.RELEASE;

    public final String BASE_OS = version.BASE_OS;

    public final String SECURITY_PATCH = version.SECURITY_PATCH;

    public final int PREVIEW_SDK_INT = version.PREVIEW_SDK_INT;

    public final int SDK_INT = version.SDK_INT;

    public final String CODENAME = version.CODENAME;

    public final String PARTITION_NAME_SYSTEM = partition.PARTITION_NAME_SYSTEM;

    public final String SERIAL = build.SERIAL;

    public final String SUPPORTED_32_BIT_ABIS[] = build.SUPPORTED_32_BIT_ABIS;

    public final String SUPPORTED_64_BIT_ABIS[] = build.SUPPORTED_64_BIT_ABIS;

    public final String SUPPORTED_ABIS[] = build.SUPPORTED_ABIS;


    //These variables are declared as unknown first as they are only available on API levels 31 and above
    //Only if the device is of API level 31 will the scanner search for these values.
    /**
     * The model name of the device's primary system-on-chip.
     */
    public String SOC_MODEL = UNKNOWN;

    public String SOC_MANUFACTURER = UNKNOWN;

    /**
     * The SKU of the hardware (from the kernel command line)
     */
    public String SKU = UNKNOWN;

    /**
     * The SKU of the device as set by the original design manufacturer (ODM)
     */
    public String ODM_SKU = UNKNOWN;

    public String RELEASE_OR_CODENAME = UNKNOWN;

    //These variables are declared as unknown as some devices may not have these information. We will use the getCPUInfo() function
    //to get their values
    public String CHIPSET = UNKNOWN;
    public String CPUARCHITECTURE = UNKNOWN;
    public String CPUFEATURES = UNKNOWN;

    //defined in the getNumberofCores() function;
    public Integer NUMBEROFCORES;


    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_scan_device);

        sdk31Info();

        NUMBEROFCORES = getNumberOfCores();
        Log.d("numberofcores", String.valueOf(NUMBEROFCORES));

        try {
            cpuinfo = getCPUInfo();
        } catch (IOException e) {
            e.printStackTrace();
        }

        for (Map.Entry<String,String> entry : cpuinfo.entrySet()) {
            String key = entry.getKey();
            String value = entry.getValue();

            Log.d("cpuinfo", key + ": " + value);

            if(key.equals("Processor")) CPUARCHITECTURE = value;
            if(key.equals("Features")) CPUFEATURES = value;
            if(key.equals("Hardware")) CHIPSET = value;

        }

        FirebaseDatabase database = FirebaseDatabase.getInstance("https://bluetoothvulnscannerdb-default-rtdb.asia-southeast1.firebasedatabase.app");
        CHIPSETDatabase = database.getReference("Chipsets");
        IOCDatabase = database.getReference("IOC");
        CVEDatabase = database.getReference("CVE");

        boardText = "sdm845";

        if (boardText != null) {

            firebaseChipset(boardText);
            Log.d("firebaseChipset","Done");

        }


        saveInfo();


//
//        //setting values of device information
//        modelValue = findViewById(R.id.modelValue);
//        modelValue.setText(MODEL + "\n" + "(" + PRODUCT + ")");
//
//        manufacturerValue = findViewById(R.id.manufacturerValue);
//        manufacturerValue.setText(MANUFACTURER);
//
//        basebandValue = findViewById(R.id.basebandValue);
//        basebandValue.setText(RADIO);
//
//        buildnumberValue = findViewById(R.id.buildnumberValue);
//        buildnumberValue.setText(DISPLAY);
//
//        buildfingerprintValue = findViewById(R.id.buildfingerprintValue);
//        buildfingerprintValue.setText(FINGERPRINT);
//
//        bootloaderValue = findViewById(R.id.bootloaderValue);
//        bootloaderValue.setText(BOOTLOADER);
//
//        osversionValue = findViewById(R.id.osversionValue);
//        osversionValue.setText(RELEASE);
//
//        sdkValue = findViewById(R.id.sdkValue);
//        //need to convert to string because setText does not take in integer
//        sdkValue.setText(String.valueOf(SDK_INT));
//
//
//        FirebaseDatabase database = FirebaseDatabase.getInstance("https://bluetoothvulnscannerdb-default-rtdb.asia-southeast1.firebasedatabase.app");
//        CHIPSETDatabase = database.getReference("Chipsets");
//        IOCDatabase = database.getReference("IOC");
////
//        scanDeviceButton = (Button) findViewById(R.id.scanDeviceButton);
//
//        scanDeviceButton.setOnClickListener(new View.OnClickListener() {
//            @Override
//            public void onClick(View view) {
//                boardText = BOARD;
////                Log.d("ScanDevice", "array is: " + BOARD);
//
//                if (boardText != null) {
//                    firebaseChipset(boardText);
////                    textView.setText("Your board text is " + finalbtsoc);
//                }
//
//                //firebaseBTSOC function will only run if the finalbtsoc value is set in the previous function.
//                if (finalbtsoc != null){
//                    firebaseBTSOC(finalbtsoc);
////                    textView.setText(output);
//                }
//
////                saveInfo();
////                textView.setText("Your Board Version is: " + output);
//            }
//        });
//
//        saveInfo();
//        testingValue = findViewById(R.id.testingValue);
//        testingValue.setText(information);

        tabLayout = findViewById(R.id.tabLayout);
        viewPager = findViewById(R.id.viewpager);
        tabLayout.setupWithViewPager(viewPager);

        VPAdapter vpAdaper = new VPAdapter(getSupportFragmentManager(), FragmentPagerAdapter.BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT);
        vpAdaper.addFragment(new fragment1(), "Device Info");
        vpAdaper.addFragment(new fragment2(), "Vulnerability Assessment");
        viewPager.setAdapter(vpAdaper);

    }

    //This method is to search database for the SoC
//    private void firebaseChipset(String boardText){
//        Toast.makeText(ScanDevice.this, "started search", Toast.LENGTH_LONG).show();
//        Query firebaseSearchQuery = CHIPSETDatabase.orderByChild("Chipset").equalTo(boardText);
//        firebaseSearchQuery.addListenerForSingleValueEvent(new ValueEventListener() {
//
//
//            @Override
//            public void onDataChange(@NonNull DataSnapshot snapshot) {
//
//                if(snapshot.exists()){
//
//                //creation of array list to store data.
//                ArrayList<HashMap<String, String>> listBTSOC = new ArrayList<HashMap<String, String>>();
//                HashMap<String, String> informationHolder = new HashMap<String, String>();
//
//                for (DataSnapshot ds:snapshot.getChildren()){
//                    //defining new hashmap to store the data. It has to be in the for loop because listBTSOC will add reference to
//                    //informationholder. It will overwrite the value.
//                    informationHolder = new HashMap<String, String>();
//
//                    //defining the values from the returned datasnapshot
//                    String btsoc = ds.child("Bluetooth SOC").getValue(String.class);
//                    String chipset = ds.child("Chipset").getValue(String.class);
//
//                    //inserting the values into hashmap with the key and value pairs.
//                    informationHolder.put("btsoc", btsoc);
//                    informationHolder.put ("chipset", chipset);
//
//                    listBTSOC.add(informationHolder);
//
//                }
//
//                //checking if the database returns more than 1 soc for the chipset. If it does, database has error.
//                if (listBTSOC.size() > 1){
//                    Log.d("ScanDevice", "array is too big database error." + listBTSOC);
//                }else if(listBTSOC.size() == 0){
//                    Log.d("ScanDevice", "array is null database error." + listBTSOC);
//                }
//                else{
//                    finalbtsoc = listBTSOC.get(0).get("btsoc");
//                    Log.d("ScanDevice", "array is " + finalbtsoc);
//                }
//            }else{
//                    Log.d("ScanDevice", "No data found");
//                }
//            }
//
//            @Override
//            public void onCancelled(@NonNull DatabaseError error) {
//                Log.d("ScanDevice", "DATABASE ERROR", error.toException());
//            }
//        });
//
//
//
//    }

//    private void firebaseBTSOC(String finalbtsoc) {
//
//        Toast.makeText(ScanDevice.this, "started search", Toast.LENGTH_LONG).show();
//        Query firebaseSearchQuery = IOCDatabase.orderByChild("BT SOC").equalTo(finalbtsoc);
//        firebaseSearchQuery.addListenerForSingleValueEvent(new ValueEventListener() {
//            @Override
//            public void onDataChange(@NonNull DataSnapshot snapshot) {
//
//                //creation of array list to store data.
//                ArrayList<HashMap<String, String>> listBTSOC = new ArrayList<HashMap<String, String>>();
//                HashMap<String, String> informationHolder = new HashMap<String, String>();
//
//                for (DataSnapshot ds:snapshot.getChildren()){
//                    //defining new hashmap to store the data. It has to be in the for loop because listBTSOC will add reference to
//                    //informationholder. It will overwrite the value.
//                    informationHolder = new HashMap<String, String>();
//
//
//                    //defining the values from the returned datasnapshot
//                    String btsoc = ds.child("BT SOC").getValue(String.class);
//                    String cpe = ds.child("CPE").getValue(String.class);
////                    String cveid = ds.child("CVE ID").getValue(String.class);
////                    String id = ds.child("ID").getValue(String.class);
//
//                    //inserting the values into hashmap with the key and value pairs.
//                    informationHolder.put("btsoc", btsoc);
//                    informationHolder.put ("cpe", cpe);
////                    informationHolder.put("cveid", cveid);
////                    informationHolder.put ("id", id);
//
//
//                    //inserting the hashmaps into an array
//                    listBTSOC.add(informationHolder);
//
////                    Log.d(TAG, "array is: " + listBTSOC);
//
//                }
//
//                if(listBTSOC.size() == 0){
//                    Log.d("ScanDevice", "  array is null." + listBTSOC);
//                }
//                else{
//                    output = "String is " + listBTSOC.get(0).get("btsoc") + ", " + listBTSOC.get(0).get("cpe");
//
//                    Log.d("ScanDevice", "  array is: " + output);
//                }
//
//
////                for (int i = 0; i < listBTSOC.size(); i++){
////                    ArrayList touch;
////                    touch=listBTSOC.get(i);
////                    Log.d(TAG, "Array : CPE is: " + touch.get(1) + ". wcn is: " + touch.get(0));
////
////                }
////                Log.d("ScanDevice", "whole array is: " + listBTSOC);
////                Log.d("ScanDevice", "first array is: " + listBTSOC.get(0).get("btsoc"));
//
//            }
//
//            @Override
//            public void onCancelled(@NonNull DatabaseError error) {
//                Log.d("ScanDevice", "DATABASE ERROR", error.toException());
//            }
//        });
//
//    }

    //TEST ON API LEVEL 31 MOBILE DEVICES!

    public void sdk31Info() {

        //These information can only be pulled if the android SDK/API level is 31 or higher
        if (SDK_INT >= 31) {

            /** The model name of the device's primary system-on-chip. */
            SOC_MODEL = build.SOC_MODEL;

            SOC_MANUFACTURER = build.SOC_MANUFACTURER;

            /** The SKU of the hardware (from the kernel command line) */
            SKU = build.SKU;

            /** The SKU of the device as set by the original design manufacturer (ODM) */
            ODM_SKU = build.ODM_SKU;

            RELEASE_OR_CODENAME = version.RELEASE_OR_CODENAME;

        }

    }


    public void saveInfo() { //store information object
        information =
                        "ID: " + ID + "\n" +
                        "DISPLAY: " + DISPLAY + "\n" +
                        "PRODUCT: " + PRODUCT + "\n" +
                        "DEVICE: " + DEVICE + "\n" +
                        "Board: " + BOARD + "\n" +
                        "MANUFACTURER: " + MANUFACTURER + "\n" +
                        "BRAND: " + BRAND + "\n" +
                        "FINGERPRINT: " + FINGERPRINT + "\n" +
                        "BOOTLOADER: " + BOOTLOADER + "\n" +
                        "HARDWARE: " + HARDWARE + "\n" +
                        "RADIO: " + RADIO + "\n" +
                        "RELEASE: " + RELEASE + "\n" +
                        "BASE_OS: " + BASE_OS + "\n" +
                        "SECURITY_PATCH: " + SECURITY_PATCH + "\n" +
                        "PREVIEW_SDK_INT: " + PREVIEW_SDK_INT + "\n" +
                        "SDK_INT: " + SDK_INT + "\n" +
                        "CODENAME: " + CODENAME + "\n" +
                        "SERIAL: " + SERIAL + "\n" +
                        "SOC_MODEL: " + SOC_MODEL + "\n" +
                        "SOC_MANUFACTURER: " + SOC_MANUFACTURER + "\n" +
                        "SKU: " + SKU + "\n" +
                        "ODM_SKU: " + ODM_SKU + "\n" +
                        "RELEASE_OR_CODENAME: " + RELEASE_OR_CODENAME + "\n" +
                        "SUPPORTED_32_BIT_ABIS: " + Arrays.toString(SUPPORTED_32_BIT_ABIS) + "\n" +
                        "SUPPORTED_64_BIT_ABIS: " + Arrays.toString(SUPPORTED_64_BIT_ABIS) + "\n" +
                        "SUPPORTED_ABIS: " + Arrays.toString(SUPPORTED_ABIS) + "\n" +
//                        "cpupresent: " + cpupresent + "\n" +
                        "cpuinfo: " + cpuinfo.get("cpu_model") + "\n" +
                        "numberofcores: " + NUMBEROFCORES + "\n" +
                        "PARTITION_NAME_SYSTEM: " + PARTITION_NAME_SYSTEM + "\n";

    }

    //much faster to get information with availableProcessors() function on devices API17+
    public int getNumberOfCores() {
        if (Build.VERSION.SDK_INT >= 17) {
            return Runtime.getRuntime().availableProcessors();
        } else {
            // for older devices before API17+
            return getNumCoresOldPhones();
        }
    }

    /**
     * Gets the number of cores available in this device, across all processors.
     * Requires: Ability to peruse the filesystem at "/sys/devices/system/cpu"
     */

    private int getNumCoresOldPhones() {
        //Private Class to display only CPU devices in the directory listing
        class CpuFilter implements FileFilter {
            @Override
            public boolean accept(File pathname) {
                //Check if filename is "cpu", followed by a single digit number
                if (Pattern.matches("cpu[0-9]+", pathname.getName())) {
                    return true;
                }
                return false;
            }
        }

        try {
            //Get directory containing CPU info
            File dir = new File("/sys/devices/system/cpu/");
            //Filter to only list the devices we care about
            File[] files = dir.listFiles(new CpuFilter());
            //Return the number of cores (virtual CPU devices)
            return files.length;
        } catch (Exception e) {
            //Default to return 1 core if failed to get result
            return 1;
        }
    }


    public static Map<String, String> getCPUInfo () throws IOException {

        BufferedReader br = new BufferedReader (new FileReader("/proc/cpuinfo"));

        String str;

        Map<String, String> output = new HashMap<>();

        while ((str = br.readLine ()) != null) {

            String[] data = str.split (":");

            if (data.length > 1) {

                String key = data[0].trim ().replace (" ", "_");
                if (key.equals ("model_name")) key = "cpu_model";

                output.put (key, data[1].trim ());
                Log.d("key", key);

            }

        }

        br.close ();

        return output;

    }

    private void firebaseChipset(String boardText){
        Query firebaseSearchQuery = CHIPSETDatabase.orderByChild("Chipset").equalTo(boardText);
        firebaseSearchQuery.addListenerForSingleValueEvent(new ValueEventListener() {


            @Override
            public void onDataChange(@NonNull DataSnapshot snapshot) {

                if(snapshot.exists()){

                    //creation of array list to store data.
                    ArrayList<HashMap<String, String>> listBTSOC = new ArrayList<HashMap<String, String>>();
                    HashMap<String, String> informationHolder = new HashMap<String, String>();

                    for (DataSnapshot ds:snapshot.getChildren()){
                        //defining new hashmap to store the data. It has to be in the for loop because listBTSOC will add reference to
                        //informationholder. It will overwrite the value.
                        informationHolder = new HashMap<String, String>();

                        //defining the values from the returned datasnapshot
                        String btsoc = ds.child("Bluetooth SOC").getValue(String.class);
                        String chipset = ds.child("Chipset").getValue(String.class);

                        //inserting the values into hashmap with the key and value pairs.
                        informationHolder.put("btsoc", btsoc);
                        informationHolder.put ("chipset", chipset);

                        if(informationHolder != null){
                            listBTSOC.add(informationHolder);
                        }

                    }

                    //checking if the database returns more than 1 soc for the chipset. If it does, database has error.
                    if (listBTSOC.size() > 1){
                        Log.d("ScanDevice", "array is too big database error." + listBTSOC);
                    }else if(listBTSOC.size() == 0){
                        Log.d("ScanDevice", "array is null database error." + listBTSOC);
                    }
                    else{
                        finalbtsoc = listBTSOC.get(0).get("btsoc");
                        Log.d("ScanDevice", "finalbtsoc: " + finalbtsoc);

                        //firebaseBTSOC function will only run if the finalbtsoc value is set in the previous function.
                        if (finalbtsoc != null){
                            firebaseBTSOC(finalbtsoc);
                            Log.d("Output", "finalbtsoc is: " + finalbtsoc);

                        }

                    }
                }else{
                    Log.d("ScanDevice", "No data found");
                }
            }

            @Override
            public void onCancelled(@NonNull DatabaseError error) {
                Log.d("ScanDevice", "DATABASE ERROR", error.toException());
            }
        });

        Log.d("endfinalbtsoc", "finalbtsoc: " + finalbtsoc);

    }

    private void firebaseBTSOC(String finalbtsoc) {

        Query firebaseSearchQuery = IOCDatabase.orderByChild("BT SOC").equalTo(finalbtsoc);
        Log.d("fragment1","finalbtsoc: " + finalbtsoc);

        firebaseSearchQuery.addListenerForSingleValueEvent(new ValueEventListener() {
            @Override
            public void onDataChange(@NonNull DataSnapshot snapshot) {

                //creation of array list to store data.

                ArrayList<HashMap<String, String>> listBTSOC = new ArrayList<HashMap<String, String>>();
                HashMap<String, String> informationHolder = new HashMap<String, String>();

                if(snapshot.exists()){

                    for (DataSnapshot ds:snapshot.getChildren()){

                        Log.d("Count", "Count: " + ds.getChildrenCount());

                        //defining new hashmap to store the data. It has to be in the for loop because listBTSOC will add reference to
                        //informationholder. It will overwrite the value.
                        informationHolder = new HashMap<String, String>();


//                    Log.v("getKey",""+ ds.getKey()); //displays the key for the node
//                    Log.v("child",""+ ds.child("CVE Related").getValue());   //gives the value for given keyname


                        //to get values of each CVE ID in the CVE Related branch
                        DataSnapshot cveid = ds.child("CVE ID Related");
                        for (DataSnapshot ds2:cveid.getChildren()){

                            Log.v("getKey","getkeyds2: "+ ds2.getKey()); //displays the key for the node
                            Log.v("child","getvalueds2: "+ ds2.getValue());   //gives the value for each children

                            cveIDArray.add(String.valueOf(ds2.getValue()));

                        }

                        for(int i = 0; i < cveIDArray.size(); i++) {
                            Log.v("testingarray",""+ cveIDArray.get(i));
                        }

                        Log.v("testingarraysize",""+ cveIDArray.size());
//
//                    int R = 0;
//                    for(int i =0; i < cveid.getChildrenCount(); i++){
//                        R++;
//
//                    }
//                    Log.v("Rvalue", String.valueOf(R));


                        //defining the values from the returned datasnapshot
                        String btsoc = ds.child("BT SOC").getValue(String.class);
                        String cpe = ds.child("CPE").getValue(String.class);
//                    String cveid = ds.child("CVEID").getValue(String.class);
//                    Object cveid = ds.child("CVE Related").getValue();
//
//                    Log.v("cveid",""+ cveid);

//                    String androidversion = ds.child("Android Version").getValue(String.class);



//                    String cveid = ds.child("CVE ID").getValue(String.class);
//                    String id = ds.child("ID").getValue(String.class);

                        //inserting the values into hashmap with the key and value pairs.
                        informationHolder.put("btsoc", btsoc);
                        informationHolder.put ("cpe", cpe);
//                    informationHolder.put ("cveid", cveid);
//                    informationHolder.put("androidversion", androidversion);

//                    informationHolder.put("cveid", cveid);
//                    informationHolder.put ("id", id);


                        //inserting the hashmaps into an array
//                    listBTSOC.add(informationHolder);

                        listBTSOC.add(informationHolder);

//                    Log.d(TAG, "array is: " + listBTSOC);

                    }



                    if(listBTSOC.size() == 0){
                        Log.d("ScanDevice", "listBTSOC is null: " + listBTSOC);
                    }
                    else{
                        output = "String is " + listBTSOC.get(0).get("btsoc") + ", " + listBTSOC.get(0).get("cpe") + ", " + listBTSOC.get(0).get("cveid") + ", " + listBTSOC.get(0).get("androidversion");

                        Log.d("ScanDevice", "output is: " + output);
                    }


//                for (int i = 0; i < listBTSOC.size(); i++){
//                    ArrayList touch;
//                    touch=listBTSOC.get(i);
//                    Log.d(TAG, "Array : CPE is: " + touch.get(1) + ". wcn is: " + touch.get(0));
//
//                }
//                Log.d("ScanDevice", "whole array is: " + listBTSOC);
//                Log.d("ScanDevice", "first array is: " + listBTSOC.get(0).get("btsoc"));



                    if(cveIDArray.size() != 0) {
                        firebaseSearchCVEByID();
                    }

                }
                else{
                    Log.d("ScanDevice", "No data found");
                }
            }

            @Override
            public void onCancelled(@NonNull DatabaseError error) {
                Log.d("ScanDevice", "DATABASE ERROR", error.toException());
            }
        });

    }


    private void firebaseSearchCVEByID(){

        for(int i = 0; i < cveIDArray.size(); i++) {

            String cveID = cveIDArray.get(i);
            Log.v("cveIDArray2",""+ cveID);

            //make sure database id is set to string!!
            Query firebaseSearchQuery = CVEDatabase.orderByChild("ID").equalTo(cveID);
            firebaseSearchQuery.addListenerForSingleValueEvent(new ValueEventListener() {
                @Override
                public void onDataChange(@NonNull DataSnapshot snapshot) {

                    Log.v("onDataChange","onDataChange SUCCESS");

                    if(snapshot.exists()){


                        HashMap<String, String> informationHolder = new HashMap<String, String>();


                        for (DataSnapshot ds:snapshot.getChildren()){

                        informationHolder = new HashMap<String, String>();

//                        String cveID = ds.child("ID").getValue(String.class);

                            informationHolder.put("cveID", cveID);

                            String cveName = ds.getKey();

                            informationHolder.put("cveName", cveName);

                            DataSnapshot cvss = ds.child("CVSS");
                            for (DataSnapshot ds2:cvss.getChildren()){

                                String key = ds2.getKey();
                                String value =  String.valueOf(ds2.getValue());

                                //only want the score for now

                                if(key.equals("Base Score")){
                                    //only want the value of the front
                                    String baseScore = value.substring(0,3);
                                    Log.v("child","getvalueds3: "+ baseScore);   //gives the value for each children

                                    informationHolder.put("baseScore", baseScore);
                                }



                                Log.v("getKey","getkeyds3: "+ ds2.getKey()); //displays the key for the node
                            }

                            cveInfo.add(informationHolder);

                            Log.d("CVEINFO", "cveInfo: " + cveInfo);

                        }


//                        Bundle bundle = new Bundle();
//                        bundle.putStringArrayList("completed", cveInfo);
//
//
//                        Log.d("bundle", "bundle: " + bundle);
//                        fragment2 fragment2 = new fragment2();
//                        fragment2.setArguments(bundle);


                    }else{
                        Log.d("ScanDevice2", "No data found2");
                    }
                }

                @Override
                public void onCancelled(@NonNull DatabaseError error) {
                    Log.d("ScanDevice", "DATABASE ERROR", error.toException());
                }
            });

        }
    }

}