package com.example.bluetoothvulnerabilityscanner;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;
import androidx.fragment.app.FragmentPagerAdapter;
import androidx.viewpager.widget.ViewPager;

import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.os.Build;
import android.os.Bundle;
import android.provider.Settings;
import android.util.Log;


import com.google.android.material.tabs.TabLayout;
import com.google.firebase.auth.FirebaseAuth;
import com.google.firebase.auth.FirebaseUser;
import com.google.firebase.database.DataSnapshot;
import com.google.firebase.database.DatabaseError;
import com.google.firebase.database.DatabaseReference;
import com.google.firebase.database.FirebaseDatabase;
import com.google.firebase.database.Query;
import com.google.firebase.database.ValueEventListener;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileFilter;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Pattern;

public class ScanDevice extends AppCompatActivity {

    private TabLayout tabLayout;
    private ViewPager viewPager;

    Context context = this;

    //defining variables
    String boardText;
    String finalbtsoc;
    String output;

    Map<String, String> cpuinfo = new HashMap<String, String>();

    Build build;
    Build.VERSION version;
    Build.Partition partition;
    String information;
    Integer scanDeviceFunctionCalls;
    Integer cveIDArrayCompilerCount;

    public ArrayList<String> cveIDArray = new ArrayList<String>();
    public ArrayList<String> cveIDArrayHolder = new ArrayList<String>();
    public ArrayList<HashMap<String, String>> cveInfo = new ArrayList<HashMap<String, String>>();

    private DatabaseReference IOCDatabase;
    private DatabaseReference CHIPSETDatabase;
    private DatabaseReference CVEDatabase;

    private static final String TAG = "ScanDevice";

    /**
     * Value used for when a build property is unknown.
     */
    public static final String UNKNOWN = "unknown";

    /**
     * Either a changelist number, or a label like "M4-rc20".
     */
    public final String ID = build.ID;

    public String ANDROIDID;

    /**
     * A build ID string meant for displaying to the user
     */
    public final String DISPLAY = build.DISPLAY;

    /**
     * The name of the overall product.
     */
    public final String PRODUCT = build.PRODUCT;

    /**
     * The name of the industrial design.
     */
    public final String DEVICE = build.DEVICE;

    /**
     * The name of the underlying board, like "goldfish".
     */
    public final String BOARD = build.BOARD;

    /**
     * The end-user-visible name for the end product.
     */
    public final String MODEL = build.MODEL;

    /**
     * The manufacturer of the product/hardware.
     */
    public final String MANUFACTURER = build.MANUFACTURER;

    /**
     * The consumer-visible brand with which the product/hardware will be associated, if any.
     */
    public final String BRAND = build.BRAND;

    /**
     * Device Fingerprint
     */
    public final String FINGERPRINT = build.FINGERPRINT;

    /**
     * The system bootloader version number.
     */
    public final String BOOTLOADER = build.BOOTLOADER;

    /**
     * The name of the hardware (from the kernel command line or /proc).
     */
    public final String HARDWARE = build.HARDWARE;

    /**
     * The name of the radio/baseband
     */
    public String RADIO = build.getRadioVersion();

    public final String RELEASE = version.RELEASE;

    public final String BASE_OS = version.BASE_OS;

    public final String SECURITY_PATCH = version.SECURITY_PATCH;

    public final int PREVIEW_SDK_INT = version.PREVIEW_SDK_INT;

    public final int SDK_INT = version.SDK_INT;

    public final String CODENAME = version.CODENAME;

    public final String PARTITION_NAME_SYSTEM = partition.PARTITION_NAME_SYSTEM;

    public final String SERIAL = build.SERIAL;

    public final String SUPPORTED_32_BIT_ABIS[] = build.SUPPORTED_32_BIT_ABIS;

    public final String SUPPORTED_64_BIT_ABIS[] = build.SUPPORTED_64_BIT_ABIS;

    public final String SUPPORTED_ABIS[] = build.SUPPORTED_ABIS;


    //These variables are declared as unknown first as they are only available on API levels 31 and above
    //Only if the device is of API level 31 will the scanner search for these values.
    /**
     * The model name of the device's primary system-on-chip.
     */
    public String SOC_MODEL = UNKNOWN;

    public String SOC_MANUFACTURER = UNKNOWN;

    /**
     * The SKU of the hardware (from the kernel command line)
     */
    public String SKU = UNKNOWN;

    /**
     * The SKU of the device as set by the original design manufacturer (ODM)
     */
    public String ODM_SKU = UNKNOWN;

    public String RELEASE_OR_CODENAME = UNKNOWN;

    //These variables are declared as unknown as some devices may not have these information. We will use the getCPUInfo() function
    //to get their values
    public String CHIPSET = UNKNOWN;
    public String CPUARCHITECTURE = UNKNOWN;
    public String CPUFEATURES = UNKNOWN;

    //defined in the getNumberofCores() function;
    public Integer NUMBEROFCORES;


    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_scan_device);
        setTitle("Scan Device");


        /**
         * Only Able to retrieve AndroidID for APIs 29++ IMEI is not possible to retrieve
         * on 3rd party applications. Android ID is not able to change aft factory reset.
         */

        ANDROIDID = Settings.Secure.getString(this.getContentResolver(), Settings.Secure.ANDROID_ID);
        Log.d("ANDROIDID", ANDROIDID);

        sdk31Info();

        NUMBEROFCORES = getNumberOfCores();
        Log.d("numberofcores", String.valueOf(NUMBEROFCORES));

        if(RADIO.equals(null) || RADIO.equals("")){
            RADIO = UNKNOWN;
        }

        try {
            cpuinfo = getCPUInfo();
        } catch (IOException e) {
            e.printStackTrace();
        }

        for (Map.Entry<String, String> entry : cpuinfo.entrySet()) {
            String key = entry.getKey();
            String value = entry.getValue();

            Log.d("cpuinfo", key + ": " + value);

            if (key.equals("Processor")) CPUARCHITECTURE = value;
            if (key.equals("Features")) CPUFEATURES = value;
            if (key.equals("Hardware")) CHIPSET = value;

        }

        FirebaseDatabase database = FirebaseDatabase.getInstance("https://bluetoothvulnscannerdb-default-rtdb.asia-southeast1.firebasedatabase.app");
        CHIPSETDatabase = database.getReference("Chipsets");
        IOCDatabase = database.getReference("IOC");
        CVEDatabase = database.getReference("CVE");

//        boardText = BOARD;
//        boardText = "sdm845";
//        boardText = "mt8175";

        //defining calls and counts
        scanDeviceFunctionCalls = 0;
        cveIDArrayCompilerCount = 0;

        String BOARD_REPLACEMENT;
        String SOC_MODEL_REPLACEMENT;
        String RELEASE_REPLACEMENT;

        BOARD_REPLACEMENT = BOARD;
        SOC_MODEL_REPLACEMENT = SOC_MODEL;
        RELEASE_REPLACEMENT = RELEASE;

        if (BOARD_REPLACEMENT.equals(null)) {
            BOARD_REPLACEMENT = "unknown";
        }

        if (SOC_MODEL_REPLACEMENT.equals(null)) {
            SOC_MODEL_REPLACEMENT = "unknown";
        }

        if (RELEASE_REPLACEMENT.equals(null)) {
            RELEASE_REPLACEMENT = "unknown";
        }

        firebaseChipset(BOARD_REPLACEMENT);
        Log.d("firebaseChipset", "Done " + BOARD_REPLACEMENT);


        //only for android versions 12 as we can get the SOC_MODEL directly.
        if (SDK_INT >= 31) {

            firebaseSOC(SOC_MODEL_REPLACEMENT);
            Log.d("firebaseSOCMODEL", "Done " + SOC_MODEL);

        } else {

            //if android is not version 12++, BOARD should indicate the SOC the device is using.
            firebaseSOC(BOARD_REPLACEMENT);
            Log.d("firebaseSOC", "Done " + BOARD);
        }

        Integer dotzerochecker = RELEASE_REPLACEMENT.indexOf(".0");

        //if RELEASE version already has a ".0" This means the release may be 8.0 or 8.1.0. If it is 8.1.0, it will be a problem as
        //it is more known as android 8.1 and database also stores it as 8.1. To prevent  inssues, we will remove the ".0". This will
        //also change the normal 8.0 to a flat 8. This does not matter as in the next part, we will add it back.

        if(dotzerochecker != -1){

            Log.d(TAG, ".0 found " + dotzerochecker);
            int length = RELEASE_REPLACEMENT.length();
            RELEASE_REPLACEMENT = RELEASE_REPLACEMENT.substring(0,  length - 2);

            Log.d(TAG, "RELEASE_REPLACEMENT new value: " + RELEASE_REPLACEMENT);
        }


        Integer dotchecker = RELEASE_REPLACEMENT.indexOf(".");

        //if RELEASE version does not have a "." This means the release is a flat number like 9, 10, 11. We need to add
        // the .0 at the end to ensure the version is correct. In the database it is stored as 12.0 and not just 12.
        if (dotchecker == -1) {
            Log.d(TAG, "dot not found " + dotchecker);
            RELEASE_REPLACEMENT = RELEASE_REPLACEMENT + ".0";
        }


        firebaseAndroidOS(RELEASE_REPLACEMENT);
        Log.d("firebaseRELEASE", "Done " + RELEASE_REPLACEMENT);

//        saveInfo();

//        DeviceInfo deviceInfo = new DeviceInfo(ANDROIDID, BOARD, BRAND, FINGERPRINT, DISPLAY, CHIPSET, MODEL, RELEASE, SDK_INT, SECURITY_PATCH);
//        SubmitUserEntry(deviceInfo);

        tabLayout = findViewById(R.id.tabLayout);
        viewPager = findViewById(R.id.viewpager);
        tabLayout.setupWithViewPager(viewPager);

        AdapterVP vpAdaper = new AdapterVP(getSupportFragmentManager(), FragmentPagerAdapter.BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT);
        vpAdaper.addFragment(new fragment1(), "Device Info");
        vpAdaper.addFragment(new fragment2(), "Vulnerability Assessment");
        viewPager.setAdapter(vpAdaper);

        }

    //TEST ON API LEVEL 31 MOBILE DEVICES!
    public void sdk31Info() {

        //These information can only be pulled if the android SDK/API level is 31 or higher
        if (SDK_INT >= 31) {

            /** The model name of the device's primary system-on-chip. */
            SOC_MODEL = build.SOC_MODEL;

            SOC_MANUFACTURER = build.SOC_MANUFACTURER;

            /** The SKU of the hardware (from the kernel command line) */
            SKU = build.SKU;

            /** The SKU of the device as set by the original design manufacturer (ODM) */
            ODM_SKU = build.ODM_SKU;

            RELEASE_OR_CODENAME = version.RELEASE_OR_CODENAME;

        }

    }

    //much faster to get information with availableProcessors() function on devices API17+
    public int getNumberOfCores() {
        if (Build.VERSION.SDK_INT >= 17) {
            return Runtime.getRuntime().availableProcessors();
        } else {
            // for older devices before API17+
            return getNumCoresOldPhones();
        }
    }

    /**
     * Gets the number of cores available in this device, across all processors.
     * Requires: Ability to peruse the filesystem at "/sys/devices/system/cpu"
     */

    private int getNumCoresOldPhones() {
        //Private Class to display only CPU devices in the directory listing
        class CpuFilter implements FileFilter {
            @Override
            public boolean accept(File pathname) {
                //Check if filename is "cpu", followed by a single digit number
                if (Pattern.matches("cpu[0-9]+", pathname.getName())) {
                    return true;
                }
                return false;
            }
        }

        try {
            //Get directory containing CPU info
            File dir = new File("/sys/devices/system/cpu/");
            //Filter to only list the devices we care about
            File[] files = dir.listFiles(new CpuFilter());
            //Return the number of cores (virtual CPU devices)
            return files.length;
        } catch (Exception e) {
            //Default to return 1 core if failed to get result
            return 1;
        }
    }


    public static Map<String, String> getCPUInfo() throws IOException {

        BufferedReader br = new BufferedReader(new FileReader("/proc/cpuinfo"));

        String str;

        Map<String, String> output = new HashMap<>();

        while ((str = br.readLine()) != null) {

            String[] data = str.split(":");

            if (data.length > 1) {

                String key = data[0].trim().replace(" ", "_");
                if (key.equals("model_name")) key = "cpu_model";

                output.put(key, data[1].trim());
                Log.d("key", key);

            }

        }

        br.close();

        return output;

    }

    //This method is to search the Chipset database for the Bluetooth combo wireless SoC model of the device's chipset if any
    private void firebaseChipset(String boardText) {

        Query firebaseSearchQuery = CHIPSETDatabase.orderByChild("Chipset").equalTo(boardText);
        firebaseSearchQuery.addListenerForSingleValueEvent(new ValueEventListener() {

            @Override
            public void onDataChange(@NonNull DataSnapshot snapshot) {

                //defining btsoc as a placeholder
                String btsoc = "";

                if (snapshot.exists()) {

                    for (DataSnapshot ds : snapshot.getChildren()) {

                        //replacing the btsoc value from the returned datasnapshot
                        btsoc = ds.child("Bluetooth SOC").getValue(String.class);

                    }
                    Log.d(TAG, "btsoc: " + btsoc);

                } else {
                    Log.d(TAG, "firebaseChipset: No data found");
                }


                //run next function to search for CVE with the BlueTooth SOC of the chipset as its IOC.
                firebaseBTSOC(btsoc);
                Log.v("tropp : firebaseChipset", String.valueOf(scanDeviceFunctionCalls));
            }

            @Override
            public void onCancelled(@NonNull DatabaseError error) {
                Log.d("ScanDevice", "DATABASE ERROR", error.toException());
            }
        });


    }

    //This method is to search the IOC database for the Bluetooth combo wireless SoC model of the chipset
    private void firebaseBTSOC(String finalbtsoc) {

        Query firebaseSearchQuery = IOCDatabase.orderByChild("SOC").equalTo(finalbtsoc);
        Log.d("fragment1", "finalbtsoc: " + finalbtsoc);

        firebaseSearchQuery.addListenerForSingleValueEvent(new ValueEventListener() {
            @Override
            public void onDataChange(@NonNull DataSnapshot snapshot) {

                //creation of array list to store data.
                cveIDArray = new ArrayList<String>();

                if (snapshot.exists()) {

                    //get the main branch values.
                    for (DataSnapshot ds : snapshot.getChildren()) {

                        //to get values of each CVE ID in the CVE Related branch which is the child of the main branch.
                        DataSnapshot cveid = ds.child("CVE_ID_Related");

                        //for each child of the CVE Related branch,
                        for (DataSnapshot ds2 : cveid.getChildren()) {

                            Log.v("getKey", "getkeyds2: " + ds2.getKey()); //displays the key for the node
                            Log.v("child", "getvalueds2: " + ds2.getValue());   //gives the value for each children

                            cveIDArray.add(String.valueOf(ds2.getValue()));
                        }
                    }

                } else {

                    Log.d(TAG, "firebaseBTSOC: No data found");
                }

                scanDeviceFunctionCalls += 1;
                cveIDArrayCompiler(cveIDArray);
                Log.v("tropp : firebaseBTSOC", String.valueOf(scanDeviceFunctionCalls));

            }

            @Override
            public void onCancelled(@NonNull DatabaseError error) {
                Log.d("ScanDevice", "DATABASE ERROR", error.toException());
            }
        });

    }

    //This method is to search the IOC database for the SoC model/chipset of the device.
    private void firebaseSOC(String SOCValue) {

        Log.v(TAG, "firebaseSOC: " + SOCValue); //displays the key for the node

        Query firebaseSearchQuery = IOCDatabase.orderByChild("SOC").equalTo(SOCValue);
        firebaseSearchQuery.addListenerForSingleValueEvent(new ValueEventListener() {

            @Override
            public void onDataChange(@NonNull DataSnapshot snapshot) {

                cveIDArray = new ArrayList<String>();
                if (snapshot.exists()) {

                    Log.v(TAG, "firebaseSOC: snapshot exist"); //displays the key for the node

                    for (DataSnapshot ds : snapshot.getChildren()) {

                        DataSnapshot cveid = ds.child("CVE_ID_Related");

                        for (DataSnapshot ds2 : cveid.getChildren()) {

                            Log.v("getKey", "getkeyds2: " + ds2.getKey()); //displays the key for the node
                            Log.v("child", "getvalueds2: " + ds2.getValue());   //gives the value for each children

                            cveIDArray.add(String.valueOf(ds2.getValue()));

                        }
                    }

                } else {
                    Log.d(TAG, "firebaseSOC: No data found");
                }

                scanDeviceFunctionCalls += 1;
                cveIDArrayCompiler(cveIDArray);
                Log.v("tropp : firebaseSOC", String.valueOf(scanDeviceFunctionCalls));

            }

            @Override
            public void onCancelled(@NonNull DatabaseError error) {
                Log.d(TAG, "DATABASE ERROR", error.toException());
            }
        });




    }


    //This method is to search the IOC database for the SoC model/chipset of the device.
    private void firebaseAndroidOS(String AndroidOS) {

        Log.v(TAG, "firebaseAndroidOS: " + AndroidOS);

        Query firebaseSearchQuery = IOCDatabase.orderByChild("AndroidOS").equalTo(AndroidOS);
        firebaseSearchQuery.addListenerForSingleValueEvent(new ValueEventListener() {

            @Override
            public void onDataChange(@NonNull DataSnapshot snapshot) {
                cveIDArray = new ArrayList<String>();

                if (snapshot.exists()) {

                    Log.v(TAG, "firebaseSOC: snapshot exist"); //displays the key for the node

                    for (DataSnapshot ds : snapshot.getChildren()) {

                        DataSnapshot cveid = ds.child("CVE_ID_Related");

                        for (DataSnapshot ds2 : cveid.getChildren()) {

                            Log.v("getKey", "getkeyds2: " + ds2.getKey()); //displays the key for the node
                            Log.v("child", "getvalueds2: " + ds2.getValue());   //gives the value for each children

                            cveIDArray.add(String.valueOf(ds2.getValue()));

                        }
                    }

                } else {

                    Log.d(TAG, "firebaseAndroidOS: No data found");
                }


                scanDeviceFunctionCalls += 1;
                cveIDArrayCompiler(cveIDArray);
                Log.v("tropp : fbAndroidOS", String.valueOf(scanDeviceFunctionCalls));

            }

            @Override
            public void onCancelled(@NonNull DatabaseError error) {
                Log.d(TAG, "DATABASE ERROR", error.toException());
            }
        });

    }


    //this function compiles the arrays filled up from the previous 3 functions. This is because onData does not save data outside
    //of the function. By calling this function inside the the previous functions, it will append the values in the array and save
    //it as a whole array.
    private void cveIDArrayCompiler(ArrayList<String> cveIDArray) {

        cveIDArrayCompilerCount += 1;

        for (int i = 0; i < cveIDArray.size(); i++) {

            String cveID = cveIDArray.get(i);
            cveIDArrayHolder.add(cveID);

            Log.v(TAG, "cveIDArrayCompiler: " + cveID);
        }


        Log.v(TAG, "cveIDArrayCompilerCount: " + cveIDArrayCompilerCount);
        Log.v(TAG, "scanDeviceFunctionCalls: " + scanDeviceFunctionCalls);

        //this is to make sure the array is filled up by the previous 3 functions. the value scanDeviceFunctionCalls is incremented
        //by 1 after each function runs.
        if (scanDeviceFunctionCalls == 3) {

            firebaseSearchCVEByID();
        }

    }


    //this method is to search the CVE database for the ID given by previous methods.
    private void firebaseSearchCVEByID() {

        HashMap<String, Integer> cveFrequencyMap = new HashMap<String, Integer>();

        for (int i = 0; i < cveIDArrayHolder.size(); i++) {

            String cveID = cveIDArrayHolder.get(i);

            //counter for each cveid.
            if (cveFrequencyMap.containsKey(cveID)) {
                cveFrequencyMap.put(cveID, cveFrequencyMap.get(cveID) + 1);
            } else {
                cveFrequencyMap.put(cveID, 1);
            }

            Log.v("cveIDArray", "" + cveID);

        }

        for (Map.Entry<String, Integer> entry : cveFrequencyMap.entrySet()) {
            String cveID = entry.getKey();
            Integer count = entry.getValue();


            Query firebaseSearchQuery = CVEDatabase.orderByChild("ID").equalTo(cveID);
            firebaseSearchQuery.addListenerForSingleValueEvent(new ValueEventListener() {
                @Override
                public void onDataChange(@NonNull DataSnapshot snapshot) {

                    Log.v("onDataChange", "onDataChange SUCCESS");

                    if (snapshot.exists()) {


                        HashMap<String, String> informationHolder = new HashMap<String, String>();

                        for (DataSnapshot ds : snapshot.getChildren()) {

                            Log.v(TAG,"CVEIDSEARCH: " + ds.getKey());

                            informationHolder = new HashMap<String, String>();

                            String cveID = ds.child("ID").getValue(String.class);

                            Integer cveCountRequired = ds.child("countRequired").getValue(Integer.class);

                            informationHolder.put("cveID", cveID);

                            String cveName = ds.getKey();

                            informationHolder.put("cveName", cveName);

                            Log.v("cveFrequencyMap: ", cveID + " " + cveName + " " + count);

                            DataSnapshot cvss = ds.child("CVSS");
                            for (DataSnapshot ds2 : cvss.getChildren()) {

                                String key = ds2.getKey();
                                String value = String.valueOf(ds2.getValue());

                                //only want the score for now

                                if (key.equals("Base Score")) {
                                    //only want the value of the front
                                    String baseScore = value.substring(0, 4);
                                    Log.v("child", "getvalueds3: " + baseScore);   //gives the value for each children

                                    informationHolder.put("baseScore", baseScore);
                                }

                                Log.v(TAG, "getkeyds3: " + ds2.getKey()); //displays the key for the node
                            }

                            //only if the count matches, add the cveinfo into the array. This is to ensure the device has hit
                            //2 or more IOCs as some CVEs require 2 IOCs to be considered vulnerable.


                            if (cveCountRequired == count) {

                                cveInfo.add(informationHolder);

                                Log.d(TAG, "cveCountRequired: matched. " + cveCountRequired + ":" + cveFrequencyMap.get(cveID) + "  " + cveName);

                            } else if (cveCountRequired > cveFrequencyMap.get(cveID)) {

                                Log.d(TAG, "cveCountRequired greater. Not enough counts. " + cveCountRequired + ":" + cveFrequencyMap.get(cveID) + "  " + cveName);

                            } else {

                                Log.d(TAG, "cveCountRequired smaller. Possible function errors. " + cveCountRequired + ":" + cveFrequencyMap.get(cveID) + "  " + cveName);

                            }
                        }

                    } else {
                        Log.d(TAG, "No data found");
                    }
                }

                @Override
                public void onCancelled(@NonNull DatabaseError error) {
                    Log.d(TAG, "DATABASE ERROR", error.toException());
                }
            });

        }

    }

}