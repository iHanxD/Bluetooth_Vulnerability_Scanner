package com.example.bluetoothvulnerabilityscanner;

import android.os.Build;
import android.os.Bundle;

import androidx.fragment.app.Fragment;

import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Pattern;

public class fragment1 extends Fragment {

//    // TODO: Rename parameter arguments, choose names that match
//    // the fragment initialization parameters, e.g. ARG_ITEM_NUMBER
//    private static final String ARG_PARAM1 = "param1";
//    private static final String ARG_PARAM2 = "param2";
//
//    // TODO: Rename and change types of parameters
//    private String mParam1;
//    private String mParam2;
//
//    public fragment1() {
//        // Required empty public constructor
//    }
//
//    // TODO: Rename and change types and number of parameters
//    public static fragment1 newInstance(String param1, String param2) {
//        fragment1 fragment = new fragment1();
//        Bundle args = new Bundle();
//        args.putString(ARG_PARAM1, param1);
//        args.putString(ARG_PARAM2, param2);
//        fragment.setArguments(args);
//        return fragment;
//    }
//

    //defining variables
    View root;
    TextView modelValue;
    TextView manufacturerValue;
    TextView basebandValue;
    TextView buildnumberValue;
    TextView buildfingerprintValue;
    TextView bootloaderValue;
    TextView osversionValue;
    TextView sdkValue;

    Map<String, String> cpuinfo = new HashMap<String, String>();

    TextView testingValue;

    Build build;
    Build.VERSION version;
    Build.Partition partition;
    String information;
//    String cpupresent;
//    String cpupossible;


//    private static final String TAG = "Build";

    /**
     * Value used for when a build property is unknown.
     */
    public static final String UNKNOWN = "unknown";

    /**
     * Either a changelist number, or a label like "M4-rc20".
     */
    public final String ID = build.ID;

    /**
     * A build ID string meant for displaying to the user
     */
    public final String DISPLAY = build.DISPLAY;

    /**
     * The name of the overall product.
     */
    public final String PRODUCT = build.PRODUCT;

    /**
     * The name of the industrial design.
     */
    public final String DEVICE = build.DEVICE;

    /**
     * The name of the underlying board, like "goldfish".
     */
    public final String BOARD = build.BOARD;

    /**
     * The end-user-visible name for the end product.
     */
    public final String MODEL = build.MODEL;

    /**
     * The manufacturer of the product/hardware.
     */
    public final String MANUFACTURER = build.MANUFACTURER;

    /**
     * The consumer-visible brand with which the product/hardware will be associated, if any.
     */
    public final String BRAND = build.BRAND;

    /**
     * Device Fingerprint
     */
    public final String FINGERPRINT = build.FINGERPRINT;

    /**
     * The system bootloader version number.
     */
    public final String BOOTLOADER = build.BOOTLOADER;

    /**
     * The name of the hardware (from the kernel command line or /proc).
     */
    public final String HARDWARE = build.HARDWARE;

    /**
     * The name of the radio/baseband
     */
    public final String RADIO = build.getRadioVersion();

    public final String RELEASE = version.RELEASE;

    public final String BASE_OS = version.BASE_OS;

    public final String SECURITY_PATCH = version.SECURITY_PATCH;

    public final int PREVIEW_SDK_INT = version.PREVIEW_SDK_INT;

    public final int SDK_INT = version.SDK_INT;

    public final String CODENAME = version.CODENAME;

    public final String PARTITION_NAME_SYSTEM = partition.PARTITION_NAME_SYSTEM;

    public final String SERIAL = build.SERIAL;

    public final String SUPPORTED_32_BIT_ABIS[] = build.SUPPORTED_32_BIT_ABIS;

    public final String SUPPORTED_64_BIT_ABIS[] = build.SUPPORTED_64_BIT_ABIS;

    public final String SUPPORTED_ABIS[] = build.SUPPORTED_ABIS;


    //These variables are declared as unknown first as they are only available on API levels 31 and above
    //Only if the device is of API level 31 will the scanner search for these values.
    /**
     * The model name of the device's primary system-on-chip.
     */
    public String SOC_MODEL = UNKNOWN;

    public String SOC_MANUFACTURER = UNKNOWN;

    /**
     * The SKU of the hardware (from the kernel command line)
     */
    public String SKU = UNKNOWN;

    /**
     * The SKU of the device as set by the original design manufacturer (ODM)
     */
    public String ODM_SKU = UNKNOWN;

    public String RELEASE_OR_CODENAME = UNKNOWN;

    //These variables are declared as unknown as some devices may not have these information. We will use the getCPUInfo() function
    //to get their values
    public String CHIPSET = UNKNOWN;
    public String CPUARCHITECTURE = UNKNOWN;
    public String CPUFEATURES = UNKNOWN;

    //defined in the getNumberofCores() function;
    public Integer NUMBEROFCORES;



    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        sdk31Info();
//        printNumberOfCores();
        NUMBEROFCORES = getNumberOfCores();
        Log.d("numberofcores", String.valueOf(NUMBEROFCORES));

        try {
            cpuinfo = getCPUInfo();
        } catch (IOException e) {
            e.printStackTrace();
        }

        for (Map.Entry<String,String> entry : cpuinfo.entrySet()) {
            String key = entry.getKey();
            String value = entry.getValue();

            Log.d("cpuinfo", key + ": " + value);

            if(key.equals("Processor")) CPUARCHITECTURE = value;
            if(key.equals("Features")) CPUFEATURES = value;
            if(key.equals("Hardware")) CHIPSET = value;

        }



        saveInfo();

    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        // Inflate the layout for this fragment
        root = inflater.inflate(R.layout.fragment_fragment1, container, false);

        //setting values of device information
        modelValue = root.findViewById(R.id.modelValue);
        modelValue.setText(MODEL + "\n" + "(" + PRODUCT + ")");

        manufacturerValue = root.findViewById(R.id.manufacturerValue);
        manufacturerValue.setText(MANUFACTURER);

        basebandValue = root.findViewById(R.id.basebandValue);
        basebandValue.setText(RADIO);

        buildnumberValue = root.findViewById(R.id.buildnumberValue);
        buildnumberValue.setText(DISPLAY);

        buildfingerprintValue = root.findViewById(R.id.buildfingerprintValue);
        buildfingerprintValue.setText(FINGERPRINT);

        bootloaderValue = root.findViewById(R.id.bootloaderValue);
        bootloaderValue.setText(BOOTLOADER);

        osversionValue = root.findViewById(R.id.osversionValue);
        osversionValue.setText(RELEASE);

        sdkValue = root.findViewById(R.id.sdkValue);
        //need to convert to string because setText does not take in integer
        sdkValue.setText(String.valueOf(SDK_INT));

        TextView cpuarchitectureValue = root.findViewById(R.id.cpuarchitectureValue);
        cpuarchitectureValue.setText(CPUARCHITECTURE);

        TextView boardValue = root.findViewById(R.id.boardValue);
        boardValue.setText(BOARD);

        TextView chipsetValue = root.findViewById(R.id.chipsetValue);
        chipsetValue.setText(CHIPSET);

        TextView coresValue = root.findViewById(R.id.coresValue);
        coresValue.setText(String.valueOf(NUMBEROFCORES));

        TextView instructionsetsValue = root.findViewById(R.id.instructionsetsValue);
        instructionsetsValue.setText(Arrays.toString(SUPPORTED_ABIS));

        TextView cpufeaturesValue = root.findViewById(R.id.cpufeaturesValue);
        cpufeaturesValue.setText(CPUFEATURES);

        testingValue = root.findViewById(R.id.testingValue);
        testingValue.setText(information);

        return root;

    }

    private void sdk31Info() {

        //These information can only be pulled if the android SDK/API level is 31 or higher
        if (SDK_INT >= 31) {

            /** The model name of the device's primary system-on-chip. */
            SOC_MODEL = build.SOC_MODEL;

            SOC_MANUFACTURER = build.SOC_MANUFACTURER;

            /** The SKU of the hardware (from the kernel command line) */
            SKU = build.SKU;

            /** The SKU of the device as set by the original design manufacturer (ODM) */
            ODM_SKU = build.ODM_SKU;

            RELEASE_OR_CODENAME = version.RELEASE_OR_CODENAME;

        }

    }

    private void saveInfo() { //store information object
        information =

                "ID: " + ID + "\n" +
                        "DISPLAY: " + DISPLAY + "\n" +
                        "PRODUCT: " + PRODUCT + "\n" +
                        "DEVICE: " + DEVICE + "\n" +
                        "Board: " + BOARD + "\n" +
                        "MANUFACTURER: " + MANUFACTURER + "\n" +
                        "BRAND: " + BRAND + "\n" +
                        "FINGERPRINT: " + FINGERPRINT + "\n" +
                        "BOOTLOADER: " + BOOTLOADER + "\n" +
                        "HARDWARE: " + HARDWARE + "\n" +
                        "RADIO: " + RADIO + "\n" +
                        "RELEASE: " + RELEASE + "\n" +
                        "BASE_OS: " + BASE_OS + "\n" +
                        "SECURITY_PATCH: " + SECURITY_PATCH + "\n" +
                        "PREVIEW_SDK_INT: " + PREVIEW_SDK_INT + "\n" +
                        "SDK_INT: " + SDK_INT + "\n" +
                        "CODENAME: " + CODENAME + "\n" +
                        "SERIAL: " + SERIAL + "\n" +
                        "SOC_MODEL: " + SOC_MODEL + "\n" +
                        "SOC_MANUFACTURER: " + SOC_MANUFACTURER + "\n" +
                        "SKU: " + SKU + "\n" +
                        "ODM_SKU: " + ODM_SKU + "\n" +
                        "RELEASE_OR_CODENAME: " + RELEASE_OR_CODENAME + "\n" +
                        "SUPPORTED_32_BIT_ABIS: " + Arrays.toString(SUPPORTED_32_BIT_ABIS) + "\n" +
                        "SUPPORTED_64_BIT_ABIS: " + Arrays.toString(SUPPORTED_64_BIT_ABIS) + "\n" +
                        "SUPPORTED_ABIS: " + Arrays.toString(SUPPORTED_ABIS) + "\n" +
//                        "cpupresent: " + cpupresent + "\n" +
                        "cpuinfo: " + cpuinfo.get("cpu_model") + "\n" +
                        "numberofcores: " + NUMBEROFCORES + "\n" +
                        "PARTITION_NAME_SYSTEM: " + PARTITION_NAME_SYSTEM + "\n";

    }

    //much faster to get information with availableProcessors() function on devices API17+
    private int getNumberOfCores() {
        if (Build.VERSION.SDK_INT >= 17) {
            return Runtime.getRuntime().availableProcessors();
        } else {
            // for older devices before API17+
            return getNumCoresOldPhones();
        }
    }

    /**
     * Gets the number of cores available in this device, across all processors.
     * Requires: Ability to peruse the filesystem at "/sys/devices/system/cpu"
     */

    private int getNumCoresOldPhones() {
        //Private Class to display only CPU devices in the directory listing
        class CpuFilter implements FileFilter {
            @Override
            public boolean accept(File pathname) {
                //Check if filename is "cpu", followed by a single digit number
                if (Pattern.matches("cpu[0-9]+", pathname.getName())) {
                    return true;
                }
                return false;
            }
        }

        try {
            //Get directory containing CPU info
            File dir = new File("/sys/devices/system/cpu/");
            //Filter to only list the devices we care about
            File[] files = dir.listFiles(new CpuFilter());
            //Return the number of cores (virtual CPU devices)
            return files.length;
        } catch (Exception e) {
            //Default to return 1 core if failed to get result
            return 1;
        }
    }


    public static Map<String, String> getCPUInfo () throws IOException {

        BufferedReader br = new BufferedReader (new FileReader("/proc/cpuinfo"));

        String str;

        Map<String, String> output = new HashMap<>();

        while ((str = br.readLine ()) != null) {

            String[] data = str.split (":");

            if (data.length > 1) {

                String key = data[0].trim ().replace (" ", "_");
                if (key.equals ("model_name")) key = "cpu_model";

                output.put (key, data[1].trim ());
                Log.d("key", key);

            }

        }

        br.close ();

        return output;

    }

//    private void printNumberOfCores() {
//
//        cpupresent = printFile("/sys/devices/system/cpu/present");
//        cpupossible = printFile("/sys/devices/system/cpu/possible");
//        Log.d("cpupresent", cpupresent);
//
//    }
//
//    private String printFile(String path) {
//        InputStream inputStream = null;
//        Integer cpuamt;
//
//        //base cpu amount is 1 because default to return 1 core if failed to get result
//        cpuamt = 1;
//
//        try {
//            inputStream = new FileInputStream(path);
//
//            if (inputStream != null) {
//
//                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
//                String line;
//
//
//                do {
//                    line = bufferedReader.readLine();
//                    Log.d(path, line);
//
//
//                    //number of cores translation
//                    if(line.equals("0")){
//                        cpuamt = 1;
//                    }
//                    else if(line.equals("0-1")){
//                        cpuamt = 2;
//                    }else if(line.equals("0-3")){
//                        cpuamt = 4;
//                    }else if(line.equals("0-7")){
//                        cpuamt = 8;
//                    }
//
//                    return String.valueOf(cpuamt);
//
//                } while (line != null);
//
//            }
//        } catch (Exception e) {
//
//        } finally {
//            if (inputStream != null) {
//                try {
//                    inputStream.close();
//                } catch (IOException e) {
//                }
//            }
//
//        }return String.valueOf(cpuamt);
//    }
}